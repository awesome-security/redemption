//
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
//

namespace cfg {
    // AUTHID_GLOBALS_CAPTURE_CHUNK
    // type: bool
    // sesman -> proxy
    // value{}
    struct globals::capture_chunk {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "capture_chunk"; }
        static constexpr authid_t index() { return authid_t(0); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_AUTH_USER
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct globals::auth_user {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "auth_user"; }
        static constexpr authid_t index() { return authid_t(1); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_HOST
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct globals::host {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "host"; }
        static constexpr authid_t index() { return authid_t(2); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_TARGET
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct globals::target {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "target"; }
        static constexpr authid_t index() { return authid_t(3); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_TARGET_DEVICE
    // type: std::string
    // sesman -> proxy
    // value{}
    struct globals::target_device {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "target_device"; }
        static constexpr authid_t index() { return authid_t(4); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_DEVICE_ID
    // type: std::string
    // sesman -> proxy
    // value{}
    struct globals::device_id {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "device_id"; }
        static constexpr authid_t index() { return authid_t(5); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_PRIMARY_USER_ID
    // type: std::string
    // sesman -> proxy
    // value{}
    struct globals::primary_user_id {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "primary_user_id"; }
        static constexpr authid_t index() { return authid_t(6); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_TARGET_USER
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct globals::target_user {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "target_user"; }
        static constexpr authid_t index() { return authid_t(7); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_TARGET_APPLICATION
    // type: std::string
    // sesman -> proxy
    // value{}
    struct globals::target_application {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "target_application"; }
        static constexpr authid_t index() { return authid_t(8); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_TARGET_APPLICATION_ACCOUNT
    // type: std::string
    // sesman -> proxy
    // value{}
    struct globals::target_application_account {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "target_application_account"; }
        static constexpr authid_t index() { return authid_t(9); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_GLOBALS_TARGET_APPLICATION_PASSWORD
    // type: std::string
    // sesman -> proxy
    // value{}
    struct globals::target_application_password {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "target_application_password"; }
        static constexpr authid_t index() { return authid_t(10); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // Support of Bitmap Cache.
    // type: bool
    // value{1}
    struct globals::bitmap_cache {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "bitmap_cache"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // type: bool
    // value{0}
    struct globals::glyph_cache {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "glyph_cache"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: unsigned int
    // value{3389}
    struct globals::port {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "port"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{3389};
    };
    // type: bool
    // value{0}
    struct globals::nomouse {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "nomouse"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: bool
    // value{0}
    struct globals::notimestamp {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "notimestamp"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: Level
    // value{static_cast<type>(0)}
    struct globals::encryptionLevel {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "encryptionLevel"; }
        using type = Level;
        using sesman_and_spec_type = Level;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(0)};
    };
    // type: std::string
    // value = "/tmp/redemption-sesman-sock"
    struct globals::authfile {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "authfile"; }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "/tmp/redemption-sesman-sock";
    };
    // Time out during RDP handshake stage.
    // type: std::chrono::seconds
    // value{10}
    struct globals::handshake_timeout {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "handshake_timeout"; }
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{10};
    };
    // No traffic auto disconnection.
    // type: std::chrono::seconds
    // value{900}
    struct globals::session_timeout {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "session_timeout"; }
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{900};
    };
    // Keepalive.
    // type: std::chrono::seconds
    // value{30}
    struct globals::keepalive_grace_delay {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "keepalive_grace_delay"; }
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{30};
    };
    // Specifies the time to spend on the login screen of proxy RDP before closing client window (0 to desactivate).
    // type: std::chrono::seconds
    // value{120}
    struct globals::authentication_timeout {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "authentication_timeout"; }
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{120};
    };
    // Specifies the time to spend on the close box of proxy RDP before closing client window (0 to desactivate).
    // type: std::chrono::seconds
    // value{600}
    struct globals::close_timeout {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "close_timeout"; }
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    // AUTHID_GLOBALS_TRACE_TYPE
    // type: TraceType
    // sesman -> proxy
    // value{static_cast<type>(1)}
    struct globals::trace_type {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "trace_type"; }
        static constexpr authid_t index() { return authid_t(11); }
        using type = TraceType;
        using sesman_and_spec_type = TraceType;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // type: std::string
    // value = "0.0.0.0"
    struct globals::listen_address {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "listen_address"; }
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::ip;
        using mapped_type = sesman_and_spec_type;
        type value = "0.0.0.0";
    };
    // Allow Transparent mode.
    // type: bool
    // value{0}
    struct globals::enable_transparent_mode {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "enable_transparent_mode"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Proxy certificate password.
    // type: char[255]
    // value = "inquisition"
    struct globals::certificate_password {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "certificate_password"; }
        using type = char[255];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "inquisition";
    };
    // type: ::configs::spec_types::directory_path
    // value = PNG_PATH
    struct globals::png_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "png_path"; }
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = PNG_PATH;
    };
    // type: ::configs::spec_types::directory_path
    // value = WRM_PATH
    struct globals::wrm_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "wrm_path"; }
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = WRM_PATH;
    };
    // AUTHID_GLOBALS_IS_REC
    // type: bool
    // sesman -> proxy
    // value{0}
    struct globals::is_rec {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "is_rec"; }
        static constexpr authid_t index() { return authid_t(12); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_GLOBALS_MOVIE_PATH
    // type: std::string
    // sesman -> proxy
    // value{}
    struct globals::movie_path {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "movie_path"; }
        static constexpr authid_t index() { return authid_t(13); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // Support of Bitmap Update.
    // type: bool
    // value{1}
    struct globals::enable_bitmap_update {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "enable_bitmap_update"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Show close screen.
    // type: bool
    // value{1}
    struct globals::enable_close_box {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "enable_close_box"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // type: bool
    // value{1}
    struct globals::enable_osd {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "enable_osd"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // type: bool
    // value{1}
    struct globals::enable_osd_display_remote_target {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "enable_osd_display_remote_target"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // type: ::configs::spec_types::directory_path
    // value = PERSISTENT_PATH
    struct globals::persistent_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "persistent_path"; }
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = PERSISTENT_PATH;
    };
    // type: bool
    // value{0}
    struct globals::enable_wab_integration {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "enable_wab_integration"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: bool
    // value{0}
    struct globals::allow_using_multiple_monitors {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "allow_using_multiple_monitors"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Needed to refresh screen of Windows Server 2012.
    // type: bool
    // value{1}
    struct globals::bogus_refresh_rect {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "bogus_refresh_rect"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // type: std::string
    // value = "flv"
    struct globals::codec_id {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "codec_id"; }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "flv";
    };
    // type: Level
    // value{static_cast<type>(2)}
    struct globals::video_quality {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "video_quality"; }
        using type = Level;
        using sesman_and_spec_type = Level;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(2)};
    };
    // type: bool
    // value{1}
    struct globals::large_pointer_support {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "globals"; }
        static constexpr char const * name() { return "large_pointer_support"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };

    // type: bool
    // value{1}
    struct session_log::enable_session_log {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "session_log"; }
        static constexpr char const * name() { return "enable_session_log"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Log redirection in a file
    // AUTHID_SESSION_LOG_SESSION_LOG_REDIRECTION
    // type: bool
    // sesman <- proxy
    // value{1}
    struct session_log::session_log_redirection {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "session_log"; }
        static constexpr char const * name() { return "session_log_redirection"; }
        static constexpr authid_t index() { return authid_t(14); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // AUTHID_SESSION_LOG_LOG_PATH
    // type: std::string
    // sesman -> proxy
    // value{}
    struct session_log::log_path {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "session_log"; }
        static constexpr char const * name() { return "log_path"; }
        static constexpr authid_t index() { return authid_t(15); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: KeyboardInputMaskingLevel
    // value{static_cast<type>(3)}
    struct session_log::keyboard_input_masking_level {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "session_log"; }
        static constexpr char const * name() { return "keyboard_input_masking_level"; }
        using type = KeyboardInputMaskingLevel;
        using sesman_and_spec_type = KeyboardInputMaskingLevel;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(3)};
    };

    // AUTHID_CLIENT_KEYBOARD_LAYOUT
    // type: unsigned int
    // sesman <- proxy
    // value{0}
    struct client::keyboard_layout {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "keyboard_layout"; }
        static constexpr authid_t index() { return authid_t(16); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // cs-CZ, da-DK, de-DE, el-GR, en-US, es-ES, fi-FI.finnish, fr-FR, is-IS, it-IT, nl-NL, nb-NO, pl-PL.programmers, pt-BR.abnt, ro-RO, ru-RU, hr-HR, sk-SK, sv-SE, tr-TR.q, uk-UA, sl-SI, et-EE, lv-LV, lt-LT.ibm, mk-MK, fo-FO, mt-MT.47, se-NO, kk-KZ, ky-KG, tt-RU, mn-MN, cy-GB, lb-LU, mi-NZ, de-CH, en-GB, es-MX, fr-BE.fr, nl-BE, pt-PT, sr-La, se-SE, uz-Cy, iu-La, fr-CA, sr-Cy, en-CA.fr, fr-CH, bs-Cy, bg-BG.latin, cs-CZ.qwerty, en-IE.irish, de-DE.ibm, el-GR.220, es-ES.variation, hu-HU, en-US.dvorak, it-IT.142, pl-PL, pt-BR.abnt2, ru-RU.typewriter, sk-SK.qwerty, tr-TR.f, lv-LV.qwerty, lt-LT, mt-MT.48, se-NO.ext_norway, fr-BE, se-SE, en-CA.multilingual, en-IE, cs-CZ.programmers, el-GR.319, en-US.international, se-SE.ext_finland_sweden, bg-BG, el-GR.220_latin, en-US.dvorak_left, el-GR.319_latin, en-US.dvorak_right, el-GR.latin, el-GR.polytonic
    // type: std::string
    // value = "en-US, fr-FR, de-DE, ru-RU"
    struct client::keyboard_layout_proposals {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "keyboard_layout_proposals"; }
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value = "en-US, fr-FR, de-DE, ru-RU";
    };
    // If true, ignore password provided by RDP client, user need do login manually.
    // type: bool
    // value{0}
    struct client::ignore_logon_password {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "ignore_logon_password"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Enable font smoothing (0x80).
    // type: uint32_t
    // value{128}
    struct client::performance_flags_default {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "performance_flags_default"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{128};
    };
    // Disable theme (0x8).
// Disable mouse cursor shadows (0x20).
    // type: uint32_t
    // value{40}
    struct client::performance_flags_force_present {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "performance_flags_force_present"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };
    // type: uint32_t
    // value{0}
    struct client::performance_flags_force_not_present {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "performance_flags_force_not_present"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // If enabled, avoid automatically font smoothing in recorded session.
    // type: bool
    // value{1}
    struct client::auto_adjust_performance_flags {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "auto_adjust_performance_flags"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Fallback to RDP Legacy Encryption if client does not support TLS.
    // type: bool
    // value{0}
    struct client::tls_fallback_legacy {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "tls_fallback_legacy"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: bool
    // value{1}
    struct client::tls_support {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "tls_support"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Needed to connect with jrdp, based on bogus X224 layer code.
    // type: bool
    // value{0}
    struct client::bogus_neg_request {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "bogus_neg_request"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Needed to connect with Remmina 0.8.3 and freerdp 0.9.4, based on bogus MCS layer code.
    // type: bool
    // value{1}
    struct client::bogus_user_id {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "bogus_user_id"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // If enabled, ignore CTRL+ALT+DEL and CTRL+SHIFT+ESCAPE (or the equivalents) keyboard sequences.
    // AUTHID_CLIENT_DISABLE_TSK_SWITCH_SHORTCUTS
    // type: bool
    // sesman -> proxy
    // value{0}
    struct client::disable_tsk_switch_shortcuts {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "disable_tsk_switch_shortcuts"; }
        static constexpr authid_t index() { return authid_t(17); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: RdpCompression
    // value{static_cast<type>(4)}
    struct client::rdp_compression {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "rdp_compression"; }
        using type = RdpCompression;
        using sesman_and_spec_type = RdpCompression;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(4)};
    };
    // type: ColorDepth
    // value{static_cast<type>(24)}
    struct client::max_color_depth {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "max_color_depth"; }
        using type = ColorDepth;
        using sesman_and_spec_type = ColorDepth;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(24)};
    };
    // Persistent Disk Bitmap Cache on the front side.
    // type: bool
    // value{1}
    struct client::persistent_disk_bitmap_cache {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "persistent_disk_bitmap_cache"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Support of Cache Waiting List (this value is ignored if Persistent Disk Bitmap Cache is disabled).
    // type: bool
    // value{0}
    struct client::cache_waiting_list {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "cache_waiting_list"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // If enabled, the contents of Persistent Bitmap Caches are stored on disk.
    // type: bool
    // value{0}
    struct client::persist_bitmap_cache_on_disk {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "persist_bitmap_cache_on_disk"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Support of Bitmap Compression.
    // type: bool
    // value{1}
    struct client::bitmap_compression {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "bitmap_compression"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Enables support of Clent Fast-Path Input Event PDUs.
    // type: bool
    // value{1}
    struct client::fast_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "fast_path"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // type: bool
    // value{1}
    struct client::enable_suppress_output {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "enable_suppress_output"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // [Not configured]: Compatible with more RDP clients (less secure)
// HIGH:!ADH:!3DES:!SHA: Compatible only with MS Windows 2008 R2 client or more recent (more secure)
    // type: std::string
    // value{}
    struct client::ssl_cipher_list {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "ssl_cipher_list"; }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: bool
    // value{0}
    struct client::show_target_user_in_f12_message {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "show_target_user_in_f12_message"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: bool
    // value{0}
    struct client::enable_new_pointer_update {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "client"; }
        static constexpr char const * name() { return "enable_new_pointer_update"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };

    // type: RdpCompression
    // value{static_cast<type>(4)}
    struct mod_rdp::rdp_compression {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "rdp_compression"; }
        using type = RdpCompression;
        using sesman_and_spec_type = RdpCompression;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(4)};
    };
    // type: bool
    // value{0}
    struct mod_rdp::disconnect_on_logon_user_change {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "disconnect_on_logon_user_change"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: std::chrono::seconds
    // value{0}
    struct mod_rdp::open_session_timeout {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "open_session_timeout"; }
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Enables support of additional drawing orders:
//   15: MultiDstBlt
//   16: MultiPatBlt
//   17: MultiScrBlt
//   18: MultiOpaqueRect
//   22: Polyline
    // type: std::string
    // value = "15,16,17,18,22"
    struct mod_rdp::extra_orders {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "extra_orders"; }
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<unsigned int>;
        using mapped_type = sesman_and_spec_type;
        type value = "15,16,17,18,22";
    };
    // NLA authentication in secondary target.
    // type: bool
    // value{1}
    struct mod_rdp::enable_nla {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "enable_nla"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // If enabled, NLA authentication will try Kerberos before NTLM.
// (if enable_nla is disabled, this value is ignored).
    // type: bool
    // value{0}
    struct mod_rdp::enable_kerberos {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "enable_kerberos"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Persistent Disk Bitmap Cache on the mod side.
    // type: bool
    // value{1}
    struct mod_rdp::persistent_disk_bitmap_cache {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "persistent_disk_bitmap_cache"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Support of Cache Waiting List (this value is ignored if Persistent Disk Bitmap Cache is disabled).
    // type: bool
    // value{1}
    struct mod_rdp::cache_waiting_list {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "cache_waiting_list"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // If enabled, the contents of Persistent Bitmap Caches are stored on disk.
    // type: bool
    // value{0}
    struct mod_rdp::persist_bitmap_cache_on_disk {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "persist_bitmap_cache_on_disk"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Enables channels names (example: channel1,channel2,etc). Character * only, activate all with low priority.
    // type: std::string
    // value = "*"
    struct mod_rdp::allow_channels {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "allow_channels"; }
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value = "*";
    };
    // Disable channels names (example: channel1,channel2,etc). Character * only, deactivate all with low priority.
    // type: std::string
    // value{}
    struct mod_rdp::deny_channels {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "deny_channels"; }
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // Enables support of Server Fast-Path Update PDUs.
    // type: bool
    // value{1}
    struct mod_rdp::fast_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "fast_path"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Enables Server Redirection Support.
    // type: bool
    // value{0}
    struct mod_rdp::server_redirection_support {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "server_redirection_support"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: RedirectionInfo
    // value{}
    struct mod_rdp::redir_info {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "redir_info"; }
        using type = RedirectionInfo;
        using mapped_type = type;
        type value{};
    };
    // AUTHID_MOD_RDP_LOAD_BALANCE_INFO
    // type: std::string
    // sesman -> proxy
    // value{}
    struct mod_rdp::load_balance_info {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "load_balance_info"; }
        static constexpr authid_t index() { return authid_t(18); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // Needed to connect with VirtualBox, based on bogus TS_UD_SC_NET data block.
    // AUTHID_MOD_RDP_BOGUS_SC_NET_SIZE
    // type: bool
    // sesman -> proxy
    // value{1}
    struct mod_rdp::bogus_sc_net_size {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "bogus_sc_net_size"; }
        static constexpr authid_t index() { return authid_t(19); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // type: BogusLinuxCursor
    // value{static_cast<type>(2)}
    struct mod_rdp::bogus_linux_cursor {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "bogus_linux_cursor"; }
        using type = BogusLinuxCursor;
        using sesman_and_spec_type = BogusLinuxCursor;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(2)};
    };
    // AUTHID_MOD_RDP_PROXY_MANAGED_DRIVES
    // type: std::string
    // sesman -> proxy
    // value{}
    struct mod_rdp::proxy_managed_drives {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "proxy_managed_drives"; }
        static constexpr authid_t index() { return authid_t(20); }
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_MOD_RDP_IGNORE_AUTH_CHANNEL
    // type: bool
    // sesman -> proxy
    // value{0}
    struct mod_rdp::ignore_auth_channel {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "ignore_auth_channel"; }
        static constexpr authid_t index() { return authid_t(21); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Authentication channel used by Auto IT scripts. May be '*' to use default name. Keep empty to disable virtual channel.
    // type: char[8]
    // value = "*"
    struct mod_rdp::auth_channel {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "auth_channel"; }
        using type = char[8];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "*";
    };
    // AUTHID_MOD_RDP_ALTERNATE_SHELL
    // type: std::string
    // sesman -> proxy
    // value{}
    struct mod_rdp::alternate_shell {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "alternate_shell"; }
        static constexpr authid_t index() { return authid_t(22); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_MOD_RDP_SHELL_ARGUMENTS
    // type: std::string
    // sesman -> proxy
    // value{}
    struct mod_rdp::shell_arguments {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "shell_arguments"; }
        static constexpr authid_t index() { return authid_t(23); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_MOD_RDP_SHELL_WORKING_DIRECTORY
    // type: std::string
    // sesman -> proxy
    // value{}
    struct mod_rdp::shell_working_directory {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "shell_working_directory"; }
        static constexpr authid_t index() { return authid_t(24); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_MOD_RDP_USE_CLIENT_PROVIDED_ALTERNATE_SHELL
    // type: bool
    // sesman -> proxy
    // value{0}
    struct mod_rdp::use_client_provided_alternate_shell {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "use_client_provided_alternate_shell"; }
        static constexpr authid_t index() { return authid_t(25); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_MOD_RDP_USE_CLIENT_PROVIDED_REMOTEAPP
    // type: bool
    // sesman -> proxy
    // value{0}
    struct mod_rdp::use_client_provided_remoteapp {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "use_client_provided_remoteapp"; }
        static constexpr authid_t index() { return authid_t(26); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_MOD_RDP_USE_NATIVE_REMOTEAPP_CAPABILITY
    // type: bool
    // sesman -> proxy
    // value{1}
    struct mod_rdp::use_native_remoteapp_capability {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "use_native_remoteapp_capability"; }
        static constexpr authid_t index() { return authid_t(27); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // AUTHID_MOD_RDP_ENABLE_SESSION_PROBE
    // type: bool
    // sesman -> proxy
    // value{0}
    struct mod_rdp::enable_session_probe {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "enable_session_probe"; }
        static constexpr authid_t index() { return authid_t(28); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Minimum supported server : Windows Server 2008.
// Clipboard redirection should be remain enabled on Terminal Server.
    // AUTHID_MOD_RDP_SESSION_PROBE_USE_CLIPBOARD_BASED_LAUNCHER
    // type: bool
    // sesman -> proxy
    // value{1}
    struct mod_rdp::session_probe_use_clipboard_based_launcher {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_use_clipboard_based_launcher"; }
        static constexpr authid_t index() { return authid_t(29); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // AUTHID_MOD_RDP_SESSION_PROBE_ENABLE_LAUNCH_MASK
    // type: bool
    // sesman -> proxy
    // value{1}
    struct mod_rdp::session_probe_enable_launch_mask {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_enable_launch_mask"; }
        static constexpr authid_t index() { return authid_t(30); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // AUTHID_MOD_RDP_SESSION_PROBE_ON_LAUNCH_FAILURE
    // type: SessionProbeOnLaunchFailure
    // sesman -> proxy
    // value{static_cast<type>(2)}
    struct mod_rdp::session_probe_on_launch_failure {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_on_launch_failure"; }
        static constexpr authid_t index() { return authid_t(31); }
        using type = SessionProbeOnLaunchFailure;
        using sesman_and_spec_type = SessionProbeOnLaunchFailure;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(2)};
    };
    // This parameter is used if session_probe_on_launch_failure is 1 (disconnect user).
// 0 to disable timeout.
    // AUTHID_MOD_RDP_SESSION_PROBE_LAUNCH_TIMEOUT
    // type: std::chrono::milliseconds
    // sesman -> proxy
    // value{20000}
    struct mod_rdp::session_probe_launch_timeout {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_launch_timeout"; }
        static constexpr authid_t index() { return authid_t(32); }
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{20000};
    };
    // This parameter is used if session_probe_on_launch_failure is 0 (ignore failure and continue) or 2 (reconnect without Session Probe).
// 0 to disable timeout.
    // AUTHID_MOD_RDP_SESSION_PROBE_LAUNCH_FALLBACK_TIMEOUT
    // type: std::chrono::milliseconds
    // sesman -> proxy
    // value{7000}
    struct mod_rdp::session_probe_launch_fallback_timeout {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_launch_fallback_timeout"; }
        static constexpr authid_t index() { return authid_t(33); }
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{7000};
    };
    // Minimum supported server : Windows Server 2008.
    // AUTHID_MOD_RDP_SESSION_PROBE_START_LAUNCH_TIMEOUT_TIMER_ONLY_AFTER_LOGON
    // type: bool
    // sesman -> proxy
    // value{1}
    struct mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_start_launch_timeout_timer_only_after_logon"; }
        static constexpr authid_t index() { return authid_t(34); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // AUTHID_MOD_RDP_SESSION_PROBE_KEEPALIVE_TIMEOUT
    // type: std::chrono::milliseconds
    // sesman -> proxy
    // value{5000}
    struct mod_rdp::session_probe_keepalive_timeout {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_keepalive_timeout"; }
        static constexpr authid_t index() { return authid_t(35); }
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{5000};
    };
    // AUTHID_MOD_RDP_SESSION_PROBE_ON_KEEPALIVE_TIMEOUT_DISCONNECT_USER
    // type: bool
    // sesman -> proxy
    // value{1}
    struct mod_rdp::session_probe_on_keepalive_timeout_disconnect_user {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_on_keepalive_timeout_disconnect_user"; }
        static constexpr authid_t index() { return authid_t(36); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // End automatically a disconnected session
    // AUTHID_MOD_RDP_SESSION_PROBE_END_DISCONNECTED_SESSION
    // type: bool
    // sesman -> proxy
    // value{0}
    struct mod_rdp::session_probe_end_disconnected_session {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_end_disconnected_session"; }
        static constexpr authid_t index() { return authid_t(37); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: bool
    // value{0}
    struct mod_rdp::session_probe_customize_executable_name {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_customize_executable_name"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_MOD_RDP_SESSION_PROBE_ENABLE_LOG
    // type: bool
    // sesman -> proxy
    // value{0}
    struct mod_rdp::session_probe_enable_log {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_enable_log"; }
        static constexpr authid_t index() { return authid_t(38); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // This policy setting allows you to configure a time limit for disconnected application sessions.
// 0 to disable timeout.
    // AUTHID_MOD_RDP_SESSION_PROBE_DISCONNECTED_APPLICATION_LIMIT
    // type: std::chrono::milliseconds
    // sesman -> proxy
    // value{0}
    struct mod_rdp::session_probe_disconnected_application_limit {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_disconnected_application_limit"; }
        static constexpr authid_t index() { return authid_t(39); }
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // This policy setting allows you to configure a time limit for disconnected Terminal Services sessions.
// 0 to disable timeout.
    // AUTHID_MOD_RDP_SESSION_PROBE_DISCONNECTED_SESSION_LIMIT
    // type: std::chrono::milliseconds
    // sesman -> proxy
    // value{0}
    struct mod_rdp::session_probe_disconnected_session_limit {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_disconnected_session_limit"; }
        static constexpr authid_t index() { return authid_t(40); }
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // This parameter allows you to specify the maximum amount of time that an active Terminal Services session can be idle (without user input) before it is automatically locked by Session Probe.
// 0 to disable timeout.
    // AUTHID_MOD_RDP_SESSION_PROBE_IDLE_SESSION_LIMIT
    // type: std::chrono::milliseconds
    // sesman -> proxy
    // value{0}
    struct mod_rdp::session_probe_idle_session_limit {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_idle_session_limit"; }
        static constexpr authid_t index() { return authid_t(41); }
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: char[512]
    // value = "||CMD"
    struct mod_rdp::session_probe_exe_or_file {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_exe_or_file"; }
        using type = char[512];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "||CMD";
    };
    // type: char[512]
    // value = "/K"
    struct mod_rdp::session_probe_arguments {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "session_probe_arguments"; }
        using type = char[512];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "/K";
    };
    // Keep known server certificates on WAB
    // AUTHID_MOD_RDP_SERVER_CERT_STORE
    // type: bool
    // sesman -> proxy
    // value{1}
    struct mod_rdp::server_cert_store {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "server_cert_store"; }
        static constexpr authid_t index() { return authid_t(42); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // AUTHID_MOD_RDP_SERVER_CERT_CHECK
    // type: ServerCertCheck
    // sesman -> proxy
    // value{static_cast<type>(1)}
    struct mod_rdp::server_cert_check {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "server_cert_check"; }
        static constexpr authid_t index() { return authid_t(43); }
        using type = ServerCertCheck;
        using sesman_and_spec_type = ServerCertCheck;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // Warn if check allow connexion to server.
    // AUTHID_MOD_RDP_SERVER_ACCESS_ALLOWED_MESSAGE
    // type: ServerNotification
    // sesman -> proxy
    // value{static_cast<type>(1)}
    struct mod_rdp::server_access_allowed_message {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "server_access_allowed_message"; }
        static constexpr authid_t index() { return authid_t(44); }
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // Warn that new server certificate file was created.
    // AUTHID_MOD_RDP_SERVER_CERT_CREATE_MESSAGE
    // type: ServerNotification
    // sesman -> proxy
    // value{static_cast<type>(1)}
    struct mod_rdp::server_cert_create_message {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "server_cert_create_message"; }
        static constexpr authid_t index() { return authid_t(45); }
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // Warn that server certificate file was successfully checked.
    // AUTHID_MOD_RDP_SERVER_CERT_SUCCESS_MESSAGE
    // type: ServerNotification
    // sesman -> proxy
    // value{static_cast<type>(1)}
    struct mod_rdp::server_cert_success_message {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "server_cert_success_message"; }
        static constexpr authid_t index() { return authid_t(46); }
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // Warn that server certificate file checking failed.
    // AUTHID_MOD_RDP_SERVER_CERT_FAILURE_MESSAGE
    // type: ServerNotification
    // sesman -> proxy
    // value{static_cast<type>(1)}
    struct mod_rdp::server_cert_failure_message {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "server_cert_failure_message"; }
        static constexpr authid_t index() { return authid_t(47); }
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // Warn that server certificate check raised some internal error.
    // AUTHID_MOD_RDP_SERVER_CERT_ERROR_MESSAGE
    // type: ServerNotification
    // sesman -> proxy
    // value{static_cast<type>(1)}
    struct mod_rdp::server_cert_error_message {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "server_cert_error_message"; }
        static constexpr authid_t index() { return authid_t(48); }
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // Do not transmit client machine name or RDP server.
    // type: bool
    // value{0}
    struct mod_rdp::hide_client_name {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "hide_client_name"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: bool
    // value{0}
    struct mod_rdp::clean_up_32_bpp_cursor {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_rdp"; }
        static constexpr char const * name() { return "clean_up_32_bpp_cursor"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };

    // Enable or disable the clipboard from client (client to server).
    // AUTHID_MOD_VNC_CLIPBOARD_UP
    // type: bool
    // sesman -> proxy
    // value{}
    struct mod_vnc::clipboard_up {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_vnc"; }
        static constexpr char const * name() { return "clipboard_up"; }
        static constexpr authid_t index() { return authid_t(49); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // Enable or disable the clipboard from server (server to client).
    // AUTHID_MOD_VNC_CLIPBOARD_DOWN
    // type: bool
    // sesman -> proxy
    // value{}
    struct mod_vnc::clipboard_down {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_vnc"; }
        static constexpr char const * name() { return "clipboard_down"; }
        static constexpr authid_t index() { return authid_t(50); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // Sets the encoding types in which pixel data can be sent by the VNC server:
//   0: Raw
//   1: CopyRect
//   2: RRE
//   16: ZRLE
//   -239 (0xFFFFFF11): Cursor pseudo-encoding
    // type: std::string
    // value{}
    struct mod_vnc::encodings {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_vnc"; }
        static constexpr char const * name() { return "encodings"; }
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<int>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: bool
    // value{0}
    struct mod_vnc::allow_authentification_retries {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_vnc"; }
        static constexpr char const * name() { return "allow_authentification_retries"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // VNC server clipboard data encoding type.
    // AUTHID_MOD_VNC_SERVER_CLIPBOARD_ENCODING_TYPE
    // type: ClipboardEncodingType
    // sesman -> proxy
    // value{static_cast<type>(1)}
    struct mod_vnc::server_clipboard_encoding_type {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_vnc"; }
        static constexpr char const * name() { return "server_clipboard_encoding_type"; }
        static constexpr authid_t index() { return authid_t(51); }
        using type = ClipboardEncodingType;
        using sesman_and_spec_type = ClipboardEncodingType;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // AUTHID_MOD_VNC_BOGUS_CLIPBOARD_INFINITE_LOOP
    // type: VncBogusClipboardInfiniteLoop
    // sesman -> proxy
    // value{static_cast<type>(0)}
    struct mod_vnc::bogus_clipboard_infinite_loop {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_vnc"; }
        static constexpr char const * name() { return "bogus_clipboard_infinite_loop"; }
        static constexpr authid_t index() { return authid_t(52); }
        using type = VncBogusClipboardInfiniteLoop;
        using sesman_and_spec_type = VncBogusClipboardInfiniteLoop;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(0)};
    };

    // 0 - Wait for Escape, 1 - End session
    // type: bool
    // value{0}
    struct mod_replay::on_end_of_data {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "mod_replay"; }
        static constexpr char const * name() { return "on_end_of_data"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };

    // type: OcrVersion
    // value{static_cast<type>(2)}
    struct ocr::version {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "ocr"; }
        static constexpr char const * name() { return "version"; }
        using type = OcrVersion;
        using sesman_and_spec_type = OcrVersion;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(2)};
    };
    // type: OcrLocale
    // value{static_cast<type>(0)}
    struct ocr::locale {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "ocr"; }
        static constexpr char const * name() { return "locale"; }
        using type = OcrLocale;
        using sesman_and_spec_type = OcrLocale;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(0)};
    };
    // type: std::chrono::duration<unsigned int, std::ratio<1, 100>>
    // value{100}
    struct ocr::interval {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "ocr"; }
        static constexpr char const * name() { return "interval"; }
        using type = std::chrono::duration<unsigned int, std::ratio<1, 100>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned int, std::ratio<1, 100>>;
        using mapped_type = sesman_and_spec_type;
        type value{100};
    };
    // type: bool
    // value{1}
    struct ocr::on_title_bar_only {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "ocr"; }
        static constexpr char const * name() { return "on_title_bar_only"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // Expressed in percentage,
//   0   - all of characters need be recognized
//   100 - accept all results
    // type: unsigned int
    // value{40}
    struct ocr::max_unrecog_char_rate {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "ocr"; }
        static constexpr char const * name() { return "max_unrecog_char_rate"; }
        using type = unsigned int;
        using sesman_and_spec_type = ::configs::spec_types::range<unsigned int, 0, 100>;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };

    // type: unsigned int
    // value{33}
    struct video::capture_groupid {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "capture_groupid"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{33};
    };
    // type: CaptureFlags
    // value{static_cast<type>(3)}
    struct video::capture_flags {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "capture_flags"; }
        using type = CaptureFlags;
        using sesman_and_spec_type = CaptureFlags;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(3)};
    };
    // Frame interval.
    // type: std::chrono::duration<unsigned int, std::ratio<1, 10>>
    // value{10}
    struct video::png_interval {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "png_interval"; }
        using type = std::chrono::duration<unsigned int, std::ratio<1, 10>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned int, std::ratio<1, 10>>;
        using mapped_type = sesman_and_spec_type;
        type value{10};
    };
    // Frame interval.
    // type: std::chrono::duration<unsigned int, std::ratio<1, 100>>
    // value{40}
    struct video::frame_interval {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "frame_interval"; }
        using type = std::chrono::duration<unsigned int, std::ratio<1, 100>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned int, std::ratio<1, 100>>;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };
    // Time between 2 wrm movies.
    // type: std::chrono::seconds
    // value{600}
    struct video::break_interval {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "break_interval"; }
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    // Number of png captures to keep.
    // type: unsigned int
    // value{5}
    struct video::png_limit {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "png_limit"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    // type: ::configs::spec_types::directory_path
    // value = "/tmp/"
    struct video::replay_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "replay_path"; }
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = "/tmp/";
    };
    // type: ::configs::spec_types::directory_path
    // value = HASH_PATH
    struct video::hash_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "hash_path"; }
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = HASH_PATH;
    };
    // type: ::configs::spec_types::directory_path
    // value = RECORD_TMP_PATH
    struct video::record_tmp_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "record_tmp_path"; }
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = RECORD_TMP_PATH;
    };
    // type: ::configs::spec_types::directory_path
    // value = RECORD_PATH
    struct video::record_path {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "record_path"; }
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = RECORD_PATH;
    };
    // type: std::chrono::seconds
    // value{300}
    struct video::inactivity_timeout {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "inactivity_timeout"; }
        using type = std::chrono::seconds;
        using mapped_type = type;
        type value{300};
    };
    // Disable keyboard log:
    // type: KeyboardLogFlags
    // value{static_cast<type>(1)}
    struct video::disable_keyboard_log {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "disable_keyboard_log"; }
        using type = KeyboardLogFlags;
        using sesman_and_spec_type = KeyboardLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // Disable clipboard log:
    // type: ClipboardLogFlags
    // value{static_cast<type>(1)}
    struct video::disable_clipboard_log {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "disable_clipboard_log"; }
        using type = ClipboardLogFlags;
        using sesman_and_spec_type = ClipboardLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // Disable (redirected) file system log:
    // type: FileSystemLogFlags
    // value{static_cast<type>(1)}
    struct video::disable_file_system_log {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "disable_file_system_log"; }
        using type = FileSystemLogFlags;
        using sesman_and_spec_type = FileSystemLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // AUTHID_VIDEO_RT_DISPLAY
    // type: unsigned int
    // sesman -> proxy
    // value{0}
    struct video::rt_display {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "rt_display"; }
        static constexpr authid_t index() { return authid_t(53); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: ColorDepthSelectionStrategy
    // value{static_cast<type>(1)}
    struct video::wrm_color_depth_selection_strategy {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "wrm_color_depth_selection_strategy"; }
        using type = ColorDepthSelectionStrategy;
        using sesman_and_spec_type = ColorDepthSelectionStrategy;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // type: WrmCompressionAlgorithm
    // value{static_cast<type>(1)}
    struct video::wrm_compression_algorithm {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "wrm_compression_algorithm"; }
        using type = WrmCompressionAlgorithm;
        using sesman_and_spec_type = WrmCompressionAlgorithm;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(1)};
    };
    // type: std::chrono::seconds
    // value{0}
    struct video::flv_break_interval {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "flv_break_interval"; }
        using type = std::chrono::seconds;
        using mapped_type = type;
        type value{0};
    };
    // Bitrate for low quality.
    // type: unsigned int
    // value{10000}
    struct video::l_bitrate {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "l_bitrate"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{10000};
    };
    // Framerate for low quality.
    // type: unsigned int
    // value{5}
    struct video::l_framerate {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "l_framerate"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    // Height for low quality.
    // type: unsigned int
    // value{480}
    struct video::l_height {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "l_height"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{480};
    };
    // Width for low quality.
    // type: unsigned int
    // value{640}
    struct video::l_width {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "l_width"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{640};
    };
    // Qscale (parameter given to ffmpeg) for low quality.
    // type: unsigned int
    // value{28}
    struct video::l_qscale {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "l_qscale"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{28};
    };
    // Bitrate for medium quality.
    // type: unsigned int
    // value{20000}
    struct video::m_bitrate {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "m_bitrate"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{20000};
    };
    // Framerate for medium quality.
    // type: unsigned int
    // value{5}
    struct video::m_framerate {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "m_framerate"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    // Height for medium quality.
    // type: unsigned int
    // value{768}
    struct video::m_height {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "m_height"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{768};
    };
    // Width for medium quality.
    // type: unsigned int
    // value{1024}
    struct video::m_width {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "m_width"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1024};
    };
    // Qscale (parameter given to ffmpeg) for medium quality.
    // type: unsigned int
    // value{14}
    struct video::m_qscale {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "m_qscale"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{14};
    };
    // Bitrate for high quality.
    // type: unsigned int
    // value{30000}
    struct video::h_bitrate {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "h_bitrate"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{30000};
    };
    // Framerate for high quality.
    // type: unsigned int
    // value{5}
    struct video::h_framerate {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "h_framerate"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    // Height for high quality.
    // type: unsigned int
    // value{2048}
    struct video::h_height {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "h_height"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{2048};
    };
    // Width for high quality.
    // type: unsigned int
    // value{2048}
    struct video::h_width {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "h_width"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{2048};
    };
    // Qscale (parameter given to ffmpeg) for high quality.
    // type: unsigned int
    // value{7}
    struct video::h_qscale {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "video"; }
        static constexpr char const * name() { return "h_qscale"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{7};
    };

    // AUTHID_CRYPTO_KEY0
    // type: std::array<unsigned char, 32>
    // sesman -> proxy
    // value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }}
    struct crypto::key0 {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "crypto"; }
        static constexpr char const * name() { return "key0"; }
        static constexpr authid_t index() { return authid_t(54); }
        using type = std::array<unsigned char, 32>;
        using sesman_and_spec_type = ::configs::spec_types::fixed_binary;
        using mapped_type = sesman_and_spec_type;
        type value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }};
    };
    // AUTHID_CRYPTO_KEY1
    // type: std::array<unsigned char, 32>
    // sesman -> proxy
    // value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }}
    struct crypto::key1 {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "crypto"; }
        static constexpr char const * name() { return "key1"; }
        static constexpr authid_t index() { return authid_t(55); }
        using type = std::array<unsigned char, 32>;
        using sesman_and_spec_type = ::configs::spec_types::fixed_binary;
        using mapped_type = sesman_and_spec_type;
        type value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }};
    };
    // Use encryption for session log file.
    // type: bool
    // value{0}
    struct crypto::session_log_with_encryption {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "crypto"; }
        static constexpr char const * name() { return "session_log_with_encryption"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // Use checksum for session log file.
    // type: bool
    // value{0}
    struct crypto::session_log_with_checksum {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "crypto"; }
        static constexpr char const * name() { return "session_log_with_checksum"; }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };

    // AUTHID_REMOTE_PROGRAM_ALLOW_RESIZE_HOSTED_DESKTOP
    // type: bool
    // sesman -> proxy
    // value{1}
    struct remote_program::allow_resize_hosted_desktop {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "remote_program"; }
        static constexpr char const * name() { return "allow_resize_hosted_desktop"; }
        static constexpr authid_t index() { return authid_t(56); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };

    // type: uint32_t
    // value{}
    struct debug::x224 {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "x224"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::mcs {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "mcs"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::sec {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "sec"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::rdp {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "rdp"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::primary_orders {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "primary_orders"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::secondary_orders {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "secondary_orders"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::bitmap_update {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "bitmap_update"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::bitmap {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "bitmap"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::capture {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "capture"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::auth {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "auth"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::session {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "session"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::front {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "front"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::mod_rdp {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "mod_rdp"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::mod_vnc {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "mod_vnc"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::mod_internal {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "mod_internal"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::mod_xup {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "mod_xup"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::widget {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "widget"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::input {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "input"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::password {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "password"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::compression {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "compression"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::cache {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "cache"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::performance {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "performance"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::pass_dialog_box {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "pass_dialog_box"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::ocr {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "ocr"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: uint32_t
    // value{}
    struct debug::ffmpeg {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "ffmpeg"; }
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: unsigned int
    // value{2}
    struct debug::config {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "debug"; }
        static constexpr char const * name() { return "config"; }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{2};
    };

    // AUTHID_TRANSLATION_LANGUAGE
    // type: Language
    // sesman -> proxy
    // value{static_cast<type>(0)}
    struct translation::language {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "translation"; }
        static constexpr char const * name() { return "language"; }
        static constexpr authid_t index() { return authid_t(57); }
        using type = Language;
        using sesman_and_spec_type = Language;
        using mapped_type = sesman_and_spec_type;
        type value{static_cast<type>(0)};
    };
    // AUTHID_TRANSLATION_PASSWORD_EN
    // type: std::string
    // sesman -> proxy
    // value{}
    struct translation::password_en {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "translation"; }
        static constexpr char const * name() { return "password_en"; }
        static constexpr authid_t index() { return authid_t(58); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_TRANSLATION_PASSWORD_FR
    // type: std::string
    // sesman -> proxy
    // value{}
    struct translation::password_fr {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "translation"; }
        static constexpr char const * name() { return "password_fr"; }
        static constexpr authid_t index() { return authid_t(59); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

    // type: std::string
    // value{}
    struct internal_mod::theme {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "internal_mod"; }
        static constexpr char const * name() { return "theme"; }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

    // type: std::string
    // value{}
    struct context::movie {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "movie"; }
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    // AUTHID_CONTEXT_OPT_BITRATE
    // type: unsigned int
    // sesman -> proxy
    // value{40000}
    struct context::opt_bitrate {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "opt_bitrate"; }
        static constexpr authid_t index() { return authid_t(60); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{40000};
    };
    // AUTHID_CONTEXT_OPT_FRAMERATE
    // type: unsigned int
    // sesman -> proxy
    // value{5}
    struct context::opt_framerate {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "opt_framerate"; }
        static constexpr authid_t index() { return authid_t(61); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    // AUTHID_CONTEXT_OPT_QSCALE
    // type: unsigned int
    // sesman -> proxy
    // value{15}
    struct context::opt_qscale {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "opt_qscale"; }
        static constexpr authid_t index() { return authid_t(62); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{15};
    };
    // AUTHID_CONTEXT_OPT_BPP
    // type: unsigned int
    // sesman <-> proxy
    // value{24}
    struct context::opt_bpp {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "opt_bpp"; }
        static constexpr authid_t index() { return authid_t(63); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{24};
    };
    // AUTHID_CONTEXT_OPT_HEIGHT
    // type: unsigned int
    // sesman <-> proxy
    // value{600}
    struct context::opt_height {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "opt_height"; }
        static constexpr authid_t index() { return authid_t(64); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    // AUTHID_CONTEXT_OPT_WIDTH
    // type: unsigned int
    // sesman <-> proxy
    // value{800}
    struct context::opt_width {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "opt_width"; }
        static constexpr authid_t index() { return authid_t(65); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{800};
    };
    // type: std::string
    // value{}
    struct context::auth_error_message {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_error_message"; }
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    // AUTHID_CONTEXT_SELECTOR
    // type: bool
    // sesman -> proxy
    // value{0}
    struct context::selector {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "selector"; }
        static constexpr authid_t index() { return authid_t(66); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_CONTEXT_SELECTOR_CURRENT_PAGE
    // type: unsigned int
    // sesman <-> proxy
    // value{1}
    struct context::selector_current_page {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "selector_current_page"; }
        static constexpr authid_t index() { return authid_t(67); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // AUTHID_CONTEXT_SELECTOR_DEVICE_FILTER
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::selector_device_filter {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "selector_device_filter"; }
        static constexpr authid_t index() { return authid_t(68); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_SELECTOR_GROUP_FILTER
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::selector_group_filter {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "selector_group_filter"; }
        static constexpr authid_t index() { return authid_t(69); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_SELECTOR_PROTO_FILTER
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::selector_proto_filter {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "selector_proto_filter"; }
        static constexpr authid_t index() { return authid_t(70); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_SELECTOR_LINES_PER_PAGE
    // type: unsigned int
    // sesman <-> proxy
    // value{0}
    struct context::selector_lines_per_page {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "selector_lines_per_page"; }
        static constexpr authid_t index() { return authid_t(71); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_CONTEXT_SELECTOR_NUMBER_OF_PAGES
    // type: unsigned int
    // sesman -> proxy
    // value{1}
    struct context::selector_number_of_pages {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "selector_number_of_pages"; }
        static constexpr authid_t index() { return authid_t(72); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    // AUTHID_CONTEXT_TARGET_PASSWORD
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::target_password {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "target_password"; }
        static constexpr authid_t index() { return authid_t(73); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_TARGET_HOST
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::target_host {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "target_host"; }
        static constexpr authid_t index() { return authid_t(74); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_TARGET_STR
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::target_str {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "target_str"; }
        static constexpr authid_t index() { return authid_t(75); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_TARGET_SERVICE
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::target_service {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "target_service"; }
        static constexpr authid_t index() { return authid_t(76); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_TARGET_PORT
    // type: unsigned int
    // sesman <-> proxy
    // value{3389}
    struct context::target_port {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "target_port"; }
        static constexpr authid_t index() { return authid_t(77); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{3389};
    };
    // AUTHID_CONTEXT_TARGET_PROTOCOL
    // type: std::string
    // sesman -> proxy
    // value = "RDP"
    struct context::target_protocol {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "target_protocol"; }
        static constexpr authid_t index() { return authid_t(78); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "RDP";
    };
    // AUTHID_CONTEXT_PASSWORD
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::password {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "password"; }
        static constexpr authid_t index() { return authid_t(79); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_REPORTING
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::reporting {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "reporting"; }
        static constexpr authid_t index() { return authid_t(80); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_CHANNEL_ANSWER
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::auth_channel_answer {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_channel_answer"; }
        static constexpr authid_t index() { return authid_t(81); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_CHANNEL_TARGET
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::auth_channel_target {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_channel_target"; }
        static constexpr authid_t index() { return authid_t(82); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_MESSAGE
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::message {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "message"; }
        static constexpr authid_t index() { return authid_t(83); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_ACCEPT_MESSAGE
    // type: bool
    // sesman <- proxy
    // value{}
    struct context::accept_message {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "accept_message"; }
        static constexpr authid_t index() { return authid_t(84); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_DISPLAY_MESSAGE
    // type: bool
    // sesman <-> proxy
    // value{}
    struct context::display_message {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "display_message"; }
        static constexpr authid_t index() { return authid_t(85); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_REJECTED
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::rejected {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "rejected"; }
        static constexpr authid_t index() { return authid_t(86); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTHENTICATED
    // type: bool
    // sesman <-> proxy
    // value{0}
    struct context::authenticated {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "authenticated"; }
        static constexpr authid_t index() { return authid_t(87); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_CONTEXT_KEEPALIVE
    // type: bool
    // sesman -> proxy
    // value{0}
    struct context::keepalive {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "keepalive"; }
        static constexpr authid_t index() { return authid_t(88); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_CONTEXT_SESSION_ID
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::session_id {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "session_id"; }
        static constexpr authid_t index() { return authid_t(89); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_END_DATE_CNX
    // type: unsigned int
    // sesman -> proxy
    // value{0}
    struct context::end_date_cnx {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "end_date_cnx"; }
        static constexpr authid_t index() { return authid_t(90); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_CONTEXT_END_TIME
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::end_time {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "end_time"; }
        static constexpr authid_t index() { return authid_t(91); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_MODE_CONSOLE
    // type: std::string
    // sesman -> proxy
    // value = "allow"
    struct context::mode_console {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "mode_console"; }
        static constexpr authid_t index() { return authid_t(92); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "allow";
    };
    // AUTHID_CONTEXT_TIMEZONE
    // type: int
    // sesman -> proxy
    // value{-3600}
    struct context::timezone {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "timezone"; }
        static constexpr authid_t index() { return authid_t(93); }
        using type = int;
        using sesman_and_spec_type = int;
        using mapped_type = sesman_and_spec_type;
        type value{-3600};
    };
    // AUTHID_CONTEXT_REAL_TARGET_DEVICE
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::real_target_device {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "real_target_device"; }
        static constexpr authid_t index() { return authid_t(94); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTHENTICATION_CHALLENGE
    // type: bool
    // sesman -> proxy
    // value{}
    struct context::authentication_challenge {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "authentication_challenge"; }
        static constexpr authid_t index() { return authid_t(95); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_TICKET
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::ticket {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "ticket"; }
        static constexpr authid_t index() { return authid_t(96); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_COMMENT
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::comment {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "comment"; }
        static constexpr authid_t index() { return authid_t(97); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_DURATION
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::duration {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "duration"; }
        static constexpr authid_t index() { return authid_t(98); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_WAITINFORETURN
    // type: std::string
    // sesman <-> proxy
    // value{}
    struct context::waitinforeturn {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "waitinforeturn"; }
        static constexpr authid_t index() { return authid_t(99); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_SHOWFORM
    // type: bool
    // sesman -> proxy
    // value{0}
    struct context::showform {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "showform"; }
        static constexpr authid_t index() { return authid_t(100); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_CONTEXT_FORMFLAG
    // type: unsigned int
    // sesman <- proxy
    // value{0}
    struct context::formflag {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "formflag"; }
        static constexpr authid_t index() { return authid_t(101); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_CONTEXT_MODULE
    // type: std::string
    // sesman <-> proxy
    // value = "login"
    struct context::module {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "module"; }
        static constexpr authid_t index() { return authid_t(102); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "login";
    };
    // AUTHID_CONTEXT_FORCEMODULE
    // type: bool
    // sesman -> proxy
    // value{0}
    struct context::forcemodule {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "forcemodule"; }
        static constexpr authid_t index() { return authid_t(103); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // AUTHID_CONTEXT_PROXY_OPT
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::proxy_opt {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "proxy_opt"; }
        static constexpr authid_t index() { return authid_t(104); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_PATTERN_KILL
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::pattern_kill {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "pattern_kill"; }
        static constexpr authid_t index() { return authid_t(105); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_PATTERN_NOTIFY
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::pattern_notify {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "pattern_notify"; }
        static constexpr authid_t index() { return authid_t(106); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_OPT_MESSAGE
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::opt_message {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "opt_message"; }
        static constexpr authid_t index() { return authid_t(107); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_SESSION_PROBE_OUTBOUND_CONNECTION_MONITORING_RULES
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::session_probe_outbound_connection_monitoring_rules {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "session_probe_outbound_connection_monitoring_rules"; }
        static constexpr authid_t index() { return authid_t(108); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_SESSION_PROBE_PROCESS_MONITORING_RULES
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::session_probe_process_monitoring_rules {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "session_probe_process_monitoring_rules"; }
        static constexpr authid_t index() { return authid_t(109); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_SESSION_PROBE_EXTRA_SYSTEM_PROCESSES
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::session_probe_extra_system_processes {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "session_probe_extra_system_processes"; }
        static constexpr authid_t index() { return authid_t(110); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // type: std::string
    // value{}
    struct context::manager_disconnect_reason {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "manager_disconnect_reason"; }
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    // AUTHID_CONTEXT_DISCONNECT_REASON
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::disconnect_reason {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "disconnect_reason"; }
        static constexpr authid_t index() { return authid_t(111); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_DISCONNECT_REASON_ACK
    // type: bool
    // sesman <- proxy
    // value{0}
    struct context::disconnect_reason_ack {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "disconnect_reason_ack"; }
        static constexpr authid_t index() { return authid_t(112); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: std::string
    // value{}
    struct context::ip_target {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "ip_target"; }
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    // AUTHID_CONTEXT_RECORDING_STARTED
    // type: bool
    // sesman <- proxy
    // value{0}
    struct context::recording_started {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "recording_started"; }
        static constexpr authid_t index() { return authid_t(113); }
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    // type: bool
    // value{0}
    struct context::perform_automatic_reconnection {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "perform_automatic_reconnection"; }
        using type = bool;
        using mapped_type = type;
        type value{0};
    };
    // type: std::array<unsigned char, 28>
    // value{}
    struct context::server_auto_reconnect_packet {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "server_auto_reconnect_packet"; }
        using type = std::array<unsigned char, 28>;
        using mapped_type = type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_COMMAND
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::auth_command {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_command"; }
        static constexpr authid_t index() { return authid_t(114); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_NOTIFY
    // type: std::string
    // sesman <- proxy
    // value{}
    struct context::auth_notify {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_notify"; }
        static constexpr authid_t index() { return authid_t(115); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_NOTIFY_RAIL_EXEC_FLAGS
    // type: unsigned int
    // sesman <- proxy
    // value{}
    struct context::auth_notify_rail_exec_flags {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_notify_rail_exec_flags"; }
        static constexpr authid_t index() { return authid_t(116); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_NOTIFY_RAIL_EXEC_EXE_OR_FILE
    // type: std::string
    // sesman <- proxy
    // value{}
    struct context::auth_notify_rail_exec_exe_or_file {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 1; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_notify_rail_exec_exe_or_file"; }
        static constexpr authid_t index() { return authid_t(117); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_COMMAND_RAIL_EXEC_EXEC_RESULT
    // type: unsigned int
    // sesman -> proxy
    // value{}
    struct context::auth_command_rail_exec_exec_result {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_command_rail_exec_exec_result"; }
        static constexpr authid_t index() { return authid_t(118); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_COMMAND_RAIL_EXEC_FLAGS
    // type: unsigned int
    // sesman -> proxy
    // value{}
    struct context::auth_command_rail_exec_flags {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_command_rail_exec_flags"; }
        static constexpr authid_t index() { return authid_t(119); }
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_COMMAND_RAIL_EXEC_ORIGINAL_EXE_OR_FILE
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::auth_command_rail_exec_original_exe_or_file {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_command_rail_exec_original_exe_or_file"; }
        static constexpr authid_t index() { return authid_t(120); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_COMMAND_RAIL_EXEC_EXE_OR_FILE
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::auth_command_rail_exec_exe_or_file {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_command_rail_exec_exe_or_file"; }
        static constexpr authid_t index() { return authid_t(121); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_COMMAND_RAIL_EXEC_WORKING_DIR
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::auth_command_rail_exec_working_dir {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_command_rail_exec_working_dir"; }
        static constexpr authid_t index() { return authid_t(122); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    // AUTHID_CONTEXT_AUTH_COMMAND_RAIL_EXEC_ARGUMENTS
    // type: std::string
    // sesman -> proxy
    // value{}
    struct context::auth_command_rail_exec_arguments {
        static constexpr bool is_sesman_to_proxy() { return 1; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return "context"; }
        static constexpr char const * name() { return "auth_command_rail_exec_arguments"; }
        static constexpr authid_t index() { return authid_t(123); }
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

    // type: Theme
    // value{}
    struct theme {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return ""; }
        static constexpr char const * name() { return "theme"; }
        using type = Theme;
        using mapped_type = type;
        type value{};
    };
    // type: Font
    // value{}
    struct font {
        static constexpr bool is_sesman_to_proxy() { return 0; }
        static constexpr bool is_proxy_to_sesman() { return 0; }
        static constexpr char const * section() { return ""; }
        static constexpr char const * name() { return "font"; }
        using type = Font;
        using mapped_type = type;
        type value{};
    };

}

namespace cfg_section {
struct globals
: cfg::globals::capture_chunk
, cfg::globals::auth_user
, cfg::globals::host
, cfg::globals::target
, cfg::globals::target_device
, cfg::globals::device_id
, cfg::globals::primary_user_id
, cfg::globals::target_user
, cfg::globals::target_application
, cfg::globals::target_application_account
, cfg::globals::target_application_password
, cfg::globals::bitmap_cache
, cfg::globals::glyph_cache
, cfg::globals::port
, cfg::globals::nomouse
, cfg::globals::notimestamp
, cfg::globals::encryptionLevel
, cfg::globals::authfile
, cfg::globals::handshake_timeout
, cfg::globals::session_timeout
, cfg::globals::keepalive_grace_delay
, cfg::globals::authentication_timeout
, cfg::globals::close_timeout
, cfg::globals::trace_type
, cfg::globals::listen_address
, cfg::globals::enable_transparent_mode
, cfg::globals::certificate_password
, cfg::globals::png_path
, cfg::globals::wrm_path
, cfg::globals::is_rec
, cfg::globals::movie_path
, cfg::globals::enable_bitmap_update
, cfg::globals::enable_close_box
, cfg::globals::enable_osd
, cfg::globals::enable_osd_display_remote_target
, cfg::globals::persistent_path
, cfg::globals::enable_wab_integration
, cfg::globals::allow_using_multiple_monitors
, cfg::globals::bogus_refresh_rect
, cfg::globals::codec_id
, cfg::globals::video_quality
, cfg::globals::large_pointer_support
{ static constexpr bool is_section = true; };

struct session_log
: cfg::session_log::enable_session_log
, cfg::session_log::session_log_redirection
, cfg::session_log::log_path
, cfg::session_log::keyboard_input_masking_level
{ static constexpr bool is_section = true; };

struct client
: cfg::client::keyboard_layout
, cfg::client::keyboard_layout_proposals
, cfg::client::ignore_logon_password
, cfg::client::performance_flags_default
, cfg::client::performance_flags_force_present
, cfg::client::performance_flags_force_not_present
, cfg::client::auto_adjust_performance_flags
, cfg::client::tls_fallback_legacy
, cfg::client::tls_support
, cfg::client::bogus_neg_request
, cfg::client::bogus_user_id
, cfg::client::disable_tsk_switch_shortcuts
, cfg::client::rdp_compression
, cfg::client::max_color_depth
, cfg::client::persistent_disk_bitmap_cache
, cfg::client::cache_waiting_list
, cfg::client::persist_bitmap_cache_on_disk
, cfg::client::bitmap_compression
, cfg::client::fast_path
, cfg::client::enable_suppress_output
, cfg::client::ssl_cipher_list
, cfg::client::show_target_user_in_f12_message
, cfg::client::enable_new_pointer_update
{ static constexpr bool is_section = true; };

struct mod_rdp
: cfg::mod_rdp::rdp_compression
, cfg::mod_rdp::disconnect_on_logon_user_change
, cfg::mod_rdp::open_session_timeout
, cfg::mod_rdp::extra_orders
, cfg::mod_rdp::enable_nla
, cfg::mod_rdp::enable_kerberos
, cfg::mod_rdp::persistent_disk_bitmap_cache
, cfg::mod_rdp::cache_waiting_list
, cfg::mod_rdp::persist_bitmap_cache_on_disk
, cfg::mod_rdp::allow_channels
, cfg::mod_rdp::deny_channels
, cfg::mod_rdp::fast_path
, cfg::mod_rdp::server_redirection_support
, cfg::mod_rdp::redir_info
, cfg::mod_rdp::load_balance_info
, cfg::mod_rdp::bogus_sc_net_size
, cfg::mod_rdp::bogus_linux_cursor
, cfg::mod_rdp::proxy_managed_drives
, cfg::mod_rdp::ignore_auth_channel
, cfg::mod_rdp::auth_channel
, cfg::mod_rdp::alternate_shell
, cfg::mod_rdp::shell_arguments
, cfg::mod_rdp::shell_working_directory
, cfg::mod_rdp::use_client_provided_alternate_shell
, cfg::mod_rdp::use_client_provided_remoteapp
, cfg::mod_rdp::use_native_remoteapp_capability
, cfg::mod_rdp::enable_session_probe
, cfg::mod_rdp::session_probe_use_clipboard_based_launcher
, cfg::mod_rdp::session_probe_enable_launch_mask
, cfg::mod_rdp::session_probe_on_launch_failure
, cfg::mod_rdp::session_probe_launch_timeout
, cfg::mod_rdp::session_probe_launch_fallback_timeout
, cfg::mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon
, cfg::mod_rdp::session_probe_keepalive_timeout
, cfg::mod_rdp::session_probe_on_keepalive_timeout_disconnect_user
, cfg::mod_rdp::session_probe_end_disconnected_session
, cfg::mod_rdp::session_probe_customize_executable_name
, cfg::mod_rdp::session_probe_enable_log
, cfg::mod_rdp::session_probe_disconnected_application_limit
, cfg::mod_rdp::session_probe_disconnected_session_limit
, cfg::mod_rdp::session_probe_idle_session_limit
, cfg::mod_rdp::session_probe_exe_or_file
, cfg::mod_rdp::session_probe_arguments
, cfg::mod_rdp::server_cert_store
, cfg::mod_rdp::server_cert_check
, cfg::mod_rdp::server_access_allowed_message
, cfg::mod_rdp::server_cert_create_message
, cfg::mod_rdp::server_cert_success_message
, cfg::mod_rdp::server_cert_failure_message
, cfg::mod_rdp::server_cert_error_message
, cfg::mod_rdp::hide_client_name
, cfg::mod_rdp::clean_up_32_bpp_cursor
{ static constexpr bool is_section = true; };

struct mod_vnc
: cfg::mod_vnc::clipboard_up
, cfg::mod_vnc::clipboard_down
, cfg::mod_vnc::encodings
, cfg::mod_vnc::allow_authentification_retries
, cfg::mod_vnc::server_clipboard_encoding_type
, cfg::mod_vnc::bogus_clipboard_infinite_loop
{ static constexpr bool is_section = true; };

struct mod_replay
: cfg::mod_replay::on_end_of_data
{ static constexpr bool is_section = true; };

struct ocr
: cfg::ocr::version
, cfg::ocr::locale
, cfg::ocr::interval
, cfg::ocr::on_title_bar_only
, cfg::ocr::max_unrecog_char_rate
{ static constexpr bool is_section = true; };

struct video
: cfg::video::capture_groupid
, cfg::video::capture_flags
, cfg::video::png_interval
, cfg::video::frame_interval
, cfg::video::break_interval
, cfg::video::png_limit
, cfg::video::replay_path
, cfg::video::hash_path
, cfg::video::record_tmp_path
, cfg::video::record_path
, cfg::video::inactivity_timeout
, cfg::video::disable_keyboard_log
, cfg::video::disable_clipboard_log
, cfg::video::disable_file_system_log
, cfg::video::rt_display
, cfg::video::wrm_color_depth_selection_strategy
, cfg::video::wrm_compression_algorithm
, cfg::video::flv_break_interval
, cfg::video::l_bitrate
, cfg::video::l_framerate
, cfg::video::l_height
, cfg::video::l_width
, cfg::video::l_qscale
, cfg::video::m_bitrate
, cfg::video::m_framerate
, cfg::video::m_height
, cfg::video::m_width
, cfg::video::m_qscale
, cfg::video::h_bitrate
, cfg::video::h_framerate
, cfg::video::h_height
, cfg::video::h_width
, cfg::video::h_qscale
{ static constexpr bool is_section = true; };

struct crypto
: cfg::crypto::key0
, cfg::crypto::key1
, cfg::crypto::session_log_with_encryption
, cfg::crypto::session_log_with_checksum
{ static constexpr bool is_section = true; };

struct remote_program
: cfg::remote_program::allow_resize_hosted_desktop
{ static constexpr bool is_section = true; };

struct debug
: cfg::debug::x224
, cfg::debug::mcs
, cfg::debug::sec
, cfg::debug::rdp
, cfg::debug::primary_orders
, cfg::debug::secondary_orders
, cfg::debug::bitmap_update
, cfg::debug::bitmap
, cfg::debug::capture
, cfg::debug::auth
, cfg::debug::session
, cfg::debug::front
, cfg::debug::mod_rdp
, cfg::debug::mod_vnc
, cfg::debug::mod_internal
, cfg::debug::mod_xup
, cfg::debug::widget
, cfg::debug::input
, cfg::debug::password
, cfg::debug::compression
, cfg::debug::cache
, cfg::debug::performance
, cfg::debug::pass_dialog_box
, cfg::debug::ocr
, cfg::debug::ffmpeg
, cfg::debug::config
{ static constexpr bool is_section = true; };

struct translation
: cfg::translation::language
, cfg::translation::password_en
, cfg::translation::password_fr
{ static constexpr bool is_section = true; };

struct internal_mod
: cfg::internal_mod::theme
{ static constexpr bool is_section = true; };

struct context
: cfg::context::movie
, cfg::context::opt_bitrate
, cfg::context::opt_framerate
, cfg::context::opt_qscale
, cfg::context::opt_bpp
, cfg::context::opt_height
, cfg::context::opt_width
, cfg::context::auth_error_message
, cfg::context::selector
, cfg::context::selector_current_page
, cfg::context::selector_device_filter
, cfg::context::selector_group_filter
, cfg::context::selector_proto_filter
, cfg::context::selector_lines_per_page
, cfg::context::selector_number_of_pages
, cfg::context::target_password
, cfg::context::target_host
, cfg::context::target_str
, cfg::context::target_service
, cfg::context::target_port
, cfg::context::target_protocol
, cfg::context::password
, cfg::context::reporting
, cfg::context::auth_channel_answer
, cfg::context::auth_channel_target
, cfg::context::message
, cfg::context::accept_message
, cfg::context::display_message
, cfg::context::rejected
, cfg::context::authenticated
, cfg::context::keepalive
, cfg::context::session_id
, cfg::context::end_date_cnx
, cfg::context::end_time
, cfg::context::mode_console
, cfg::context::timezone
, cfg::context::real_target_device
, cfg::context::authentication_challenge
, cfg::context::ticket
, cfg::context::comment
, cfg::context::duration
, cfg::context::waitinforeturn
, cfg::context::showform
, cfg::context::formflag
, cfg::context::module
, cfg::context::forcemodule
, cfg::context::proxy_opt
, cfg::context::pattern_kill
, cfg::context::pattern_notify
, cfg::context::opt_message
, cfg::context::session_probe_outbound_connection_monitoring_rules
, cfg::context::session_probe_process_monitoring_rules
, cfg::context::session_probe_extra_system_processes
, cfg::context::manager_disconnect_reason
, cfg::context::disconnect_reason
, cfg::context::disconnect_reason_ack
, cfg::context::ip_target
, cfg::context::recording_started
, cfg::context::perform_automatic_reconnection
, cfg::context::server_auto_reconnect_packet
, cfg::context::auth_command
, cfg::context::auth_notify
, cfg::context::auth_notify_rail_exec_flags
, cfg::context::auth_notify_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_exec_result
, cfg::context::auth_command_rail_exec_flags
, cfg::context::auth_command_rail_exec_original_exe_or_file
, cfg::context::auth_command_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_working_dir
, cfg::context::auth_command_rail_exec_arguments
{ static constexpr bool is_section = true; };

}

namespace configs {
struct VariablesConfiguration
: cfg_section::globals
, cfg_section::session_log
, cfg_section::client
, cfg_section::mod_rdp
, cfg_section::mod_vnc
, cfg_section::mod_replay
, cfg_section::ocr
, cfg_section::video
, cfg_section::crypto
, cfg_section::remote_program
, cfg_section::debug
, cfg_section::translation
, cfg_section::internal_mod
, cfg_section::context
, cfg::theme
, cfg::font
{};

using VariablesAclPack = Pack<
  cfg::globals::capture_chunk
, cfg::globals::auth_user
, cfg::globals::host
, cfg::globals::target
, cfg::globals::target_device
, cfg::globals::device_id
, cfg::globals::primary_user_id
, cfg::globals::target_user
, cfg::globals::target_application
, cfg::globals::target_application_account
, cfg::globals::target_application_password
, cfg::globals::trace_type
, cfg::globals::is_rec
, cfg::globals::movie_path
, cfg::session_log::session_log_redirection
, cfg::session_log::log_path
, cfg::client::keyboard_layout
, cfg::client::disable_tsk_switch_shortcuts
, cfg::mod_rdp::load_balance_info
, cfg::mod_rdp::bogus_sc_net_size
, cfg::mod_rdp::proxy_managed_drives
, cfg::mod_rdp::ignore_auth_channel
, cfg::mod_rdp::alternate_shell
, cfg::mod_rdp::shell_arguments
, cfg::mod_rdp::shell_working_directory
, cfg::mod_rdp::use_client_provided_alternate_shell
, cfg::mod_rdp::use_client_provided_remoteapp
, cfg::mod_rdp::use_native_remoteapp_capability
, cfg::mod_rdp::enable_session_probe
, cfg::mod_rdp::session_probe_use_clipboard_based_launcher
, cfg::mod_rdp::session_probe_enable_launch_mask
, cfg::mod_rdp::session_probe_on_launch_failure
, cfg::mod_rdp::session_probe_launch_timeout
, cfg::mod_rdp::session_probe_launch_fallback_timeout
, cfg::mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon
, cfg::mod_rdp::session_probe_keepalive_timeout
, cfg::mod_rdp::session_probe_on_keepalive_timeout_disconnect_user
, cfg::mod_rdp::session_probe_end_disconnected_session
, cfg::mod_rdp::session_probe_enable_log
, cfg::mod_rdp::session_probe_disconnected_application_limit
, cfg::mod_rdp::session_probe_disconnected_session_limit
, cfg::mod_rdp::session_probe_idle_session_limit
, cfg::mod_rdp::server_cert_store
, cfg::mod_rdp::server_cert_check
, cfg::mod_rdp::server_access_allowed_message
, cfg::mod_rdp::server_cert_create_message
, cfg::mod_rdp::server_cert_success_message
, cfg::mod_rdp::server_cert_failure_message
, cfg::mod_rdp::server_cert_error_message
, cfg::mod_vnc::clipboard_up
, cfg::mod_vnc::clipboard_down
, cfg::mod_vnc::server_clipboard_encoding_type
, cfg::mod_vnc::bogus_clipboard_infinite_loop
, cfg::video::rt_display
, cfg::crypto::key0
, cfg::crypto::key1
, cfg::remote_program::allow_resize_hosted_desktop
, cfg::translation::language
, cfg::translation::password_en
, cfg::translation::password_fr
, cfg::context::opt_bitrate
, cfg::context::opt_framerate
, cfg::context::opt_qscale
, cfg::context::opt_bpp
, cfg::context::opt_height
, cfg::context::opt_width
, cfg::context::selector
, cfg::context::selector_current_page
, cfg::context::selector_device_filter
, cfg::context::selector_group_filter
, cfg::context::selector_proto_filter
, cfg::context::selector_lines_per_page
, cfg::context::selector_number_of_pages
, cfg::context::target_password
, cfg::context::target_host
, cfg::context::target_str
, cfg::context::target_service
, cfg::context::target_port
, cfg::context::target_protocol
, cfg::context::password
, cfg::context::reporting
, cfg::context::auth_channel_answer
, cfg::context::auth_channel_target
, cfg::context::message
, cfg::context::accept_message
, cfg::context::display_message
, cfg::context::rejected
, cfg::context::authenticated
, cfg::context::keepalive
, cfg::context::session_id
, cfg::context::end_date_cnx
, cfg::context::end_time
, cfg::context::mode_console
, cfg::context::timezone
, cfg::context::real_target_device
, cfg::context::authentication_challenge
, cfg::context::ticket
, cfg::context::comment
, cfg::context::duration
, cfg::context::waitinforeturn
, cfg::context::showform
, cfg::context::formflag
, cfg::context::module
, cfg::context::forcemodule
, cfg::context::proxy_opt
, cfg::context::pattern_kill
, cfg::context::pattern_notify
, cfg::context::opt_message
, cfg::context::session_probe_outbound_connection_monitoring_rules
, cfg::context::session_probe_process_monitoring_rules
, cfg::context::session_probe_extra_system_processes
, cfg::context::disconnect_reason
, cfg::context::disconnect_reason_ack
, cfg::context::recording_started
, cfg::context::auth_command
, cfg::context::auth_notify
, cfg::context::auth_notify_rail_exec_flags
, cfg::context::auth_notify_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_exec_result
, cfg::context::auth_command_rail_exec_flags
, cfg::context::auth_command_rail_exec_original_exe_or_file
, cfg::context::auth_command_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_working_dir
, cfg::context::auth_command_rail_exec_arguments
>;
}
