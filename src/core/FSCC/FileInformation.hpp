/*
    This program is free software; you can redistribute it and/or modify it
     under the terms of the GNU General Public License as published by the
     Free Software Foundation; either version 2 of the License, or (at your
     option) any later version.

    This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
     Public License for more details.

    You should have received a copy of the GNU General Public License along
     with this program; if not, write to the Free Software Foundation, Inc.,
     675 Mass Ave, Cambridge, MA 02139, USA.

    Product name: redemption, a FLOSS RDP proxy
    Copyright (C) Wallix 2015
    Author(s): Christophe Grosjean, Raphael Zhou, Cl√©ment Moroldo
*/


#pragma once

#include <cinttypes>
#include <inttypes.h>

#include "core/error.hpp"

#include "utils/sugar/cast.hpp"
#include "utils/stream.hpp"
#include "core/ERREF/ntstatus.hpp"

namespace fscc {

// [MS-FSCC] - 2.1.8 Boolean
// =========================

// A Boolean data type is a primitive that has one of two possible values:
//  TRUE and FALSE, which are defined as follows:

//  TRUE: A sender MUST use any nonzero value to denote a TRUE. A receiver
//   MUST interpret any nonzero value as TRUE.<9>

//  FALSE: A sender MUST use a zero value to denote a FALSE. A receiver MUST
//   interpret a zero value as FALSE.

// [MS-FSCC] - 2.2 Status Codes
// ============================

// This specification uses NTSTATUS status codes, as specified in [MS-ERREF]
//  section 2.3. The format of a status code MUST be as specified in
//  [MS-ERREF].

// The reply message for each FSCTL lists the error codes that are directly
//  generated by the function that implements the specified FSCTL. Error
//  codes also may be generated by code below the file system (such as RAID
//  drivers or disk drivers) or above the file system (such as virus
//  scanners).

// A server SHOULD return a status of STATUS_INVALID_DEVICE_REQUEST when an
//  FSCTL is not supported remotely or is not supported on the file system on
//  which the file or directory handle specified by the FSCTL exists.<10><11>

// STATUS_BUFFER_OVERFLOW is a warning code and not an error code. This
//  warning means that the given output buffer is not large enough to contain
//  all of the requested information. Unless otherwise noted, a given
//  operation SHOULD attempt to return as much data as it reasonably can.

// [MS-FSCC] - 2.3 FSCTL Structures
// ================================

// A process invokes an FSCTL on a handle to perform an action against the
//  file or directory associated with the handle. When a server receives an
//  FSCTL request, it SHOULD use the information in the request, which
//  includes a handle and, optionally, an input data buffer, to perform the
//  requested action. How a server performs the action requested by an FSCTL
//  is implementation-dependent.<12>

// The following table specifies the system-defined generic FSCTLs that are
//  permitted to be invoked across the network. Generic FSCTLs are used by
//  the local file systems or by multiple components within the system. Any
//  application, service, or driver may define private FSCTLs. Most private
//  FSCTLs are used locally in the internal driver stacks and do not flow
//  over the wire. However, if a component allows its private FSCTLs to flow
//  over the wire, that component is responsible for ensuring the FSCTLs and
//  associated data structures are documented. Examples of such private
//  FSCTLs can be found in [MS-SMB2] and [MS-DFSC].

//  +-----------------------------------------+-----------------------+
//  | FSCTL name                              | FSCTL function number |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_CREATE_OR_GET_OBJECT_ID           | 0x900c0               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_DELETE_OBJECT_ID                  | 0x900a0               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_DELETE_REPARSE_POINT              | 0x900ac               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_FILE_LEVEL_TRIM                   | 0x98208               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_FILESYSTEM_GET_STATISTICS         | 0x90060               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_FIND_FILES_BY_SID                 | 0x9008f               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_GET_COMPRESSION                   | 0x9003c               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_GET_INTEGRITY_INFORMATION         | 0x9027c               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_GET_NTFS_VOLUME_DATA              | 0x90064               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_GET_REFS_VOLUME_DATA              | 0x902D8               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_GET_OBJECT_ID                     | 0x9009c               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_GET_REPARSE_POINT                 | 0x900a8               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_GET_RETRIEVAL_POINTERS            | 0x90073               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_IS_PATHNAME_VALID                 | 0x9002c               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_LMR_SET_LINK_TRACKING_INFORMATION | 0x1400ec              |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_OFFLOAD_READ                      | 0x94264               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_OFFLOAD_WRITE                     | 0x98268               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_PIPE_PEEK                         | 0x11400c              |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_PIPE_TRANSCEIVE                   | 0x11c017              |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_PIPE_WAIT                         | 0x110018              |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_QUERY_ALLOCATED_RANGES            | 0x940cf               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_QUERY_FAT_BPB                     | 0x90058               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_QUERY_FILE_REGIONS                | 0x90284               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_QUERY_ON_DISK_VOLUME_INFO         | 0x9013c               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_QUERY_SPARING_INFO                | 0x90138               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_READ_FILE_USN_DATA                | 0x900eb               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_RECALL_FILE                       | 0x90117               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_COMPRESSION                   | 0x9c040               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_DEFECT_MANAGEMENT             | 0x98134               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_ENCRYPTION                    | 0x900D7               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_INTEGRITY_INFORMATION         | 0x9C280               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_OBJECT_ID                     | 0x90098               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_OBJECT_ID_EXTENDED            | 0x900bc               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_REPARSE_POINT                 | 0x900a4               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_SPARSE                        | 0x900c4               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_ZERO_DATA                     | 0x980c8               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SET_ZERO_ON_DEALLOCATION          | 0x90194               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_SIS_COPYFILE                      | 0x90100               |
//  +-----------------------------------------+-----------------------+
//  | FSCTL_WRITE_USN_CLOSE_RECORD            | 0x900ef               |
//  +-----------------------------------------+-----------------------+

enum {
      FSCTL_CREATE_OR_GET_OBJECT_ID           = 0x900c0
    , FSCTL_DELETE_OBJECT_ID                  = 0x900a0
    , FSCTL_DELETE_REPARSE_POINT              = 0x900ac
    , FSCTL_FILE_LEVEL_TRIM                   = 0x98208
    , FSCTL_FILESYSTEM_GET_STATISTICS         = 0x90060
    , FSCTL_FIND_FILES_BY_SID                 = 0x9008f
    , FSCTL_GET_COMPRESSION                   = 0x9003c
    , FSCTL_GET_INTEGRITY_INFORMATION         = 0x9027c
    , FSCTL_GET_NTFS_VOLUME_DATA              = 0x90064
    , FSCTL_GET_REFS_VOLUME_DATA              = 0x902D8
    , FSCTL_GET_OBJECT_ID                     = 0x9009c
    , FSCTL_GET_REPARSE_POINT                 = 0x900a8
    , FSCTL_GET_RETRIEVAL_POINTERS            = 0x90073
    , FSCTL_IS_PATHNAME_VALID                 = 0x9002c
    , FSCTL_LMR_SET_LINK_TRACKING_INFORMATION = 0x1400ec
    , FSCTL_OFFLOAD_READ                      = 0x94264
    , FSCTL_OFFLOAD_WRITE                     = 0x98268
    , FSCTL_PIPE_PEEK                         = 0x11400c
    , FSCTL_PIPE_TRANSCEIVE                   = 0x11c017
    , FSCTL_PIPE_WAIT                         = 0x110018
    , FSCTL_QUERY_ALLOCATED_RANGES            = 0x940cf
    , FSCTL_QUERY_FAT_BPB                     = 0x90058
    , FSCTL_QUERY_FILE_REGIONS                = 0x90284
    , FSCTL_QUERY_ON_DISK_VOLUME_INFO         = 0x9013c
    , FSCTL_QUERY_SPARING_INFO                = 0x90138
    , FSCTL_READ_FILE_USN_DATA                = 0x900eb
    , FSCTL_RECALL_FILE                       = 0x90117
    , FSCTL_SET_COMPRESSION                   = 0x9c040
    , FSCTL_SET_DEFECT_MANAGEMENT             = 0x98134
    , FSCTL_SET_ENCRYPTION                    = 0x900D7
    , FSCTL_SET_INTEGRITY_INFORMATION         = 0x9C280
    , FSCTL_SET_OBJECT_ID                     = 0x90098
    , FSCTL_SET_OBJECT_ID_EXTENDED            = 0x900bc
    , FSCTL_SET_REPARSE_POINT                 = 0x900a4
    , FSCTL_SET_SPARSE                        = 0x900c4
    , FSCTL_SET_ZERO_DATA                     = 0x980c8
    , FSCTL_SET_ZERO_ON_DEALLOCATION          = 0x90194
    , FSCTL_SIS_COPYFILE                      = 0x90100
    , FSCTL_WRITE_USN_CLOSE_RECORD            = 0x900ef
};


static inline
const char * get_FSCTLStructures(uint32_t FSCTLStructures) {

    switch (FSCTLStructures) {
        case FSCTL_CREATE_OR_GET_OBJECT_ID: return "FSCTL_CREATE_OR_GET_OBJECT_ID";
        case FSCTL_DELETE_OBJECT_ID:        return "FSCTL_DELETE_OBJECT_ID";
        case FSCTL_GET_OBJECT_ID:           return "FSCTL_GET_OBJECT_ID";
    }

    return "unknow";
}

// [MS-FSCC]: File System Control Codes

// 2.6 File Attributes

// The following attributes are defined for files and directories. They can be used in any combination unless noted in the description of the attribute's meaning. There is no file attribute with the value 0x00000000 because a value of 0x00000000 in the FileAttributes field means that the file attributes for this file MUST NOT be changed when setting basic information for the file.

//  +------------------------------------+-----------------------------------------------+
//  | Value                              | Meaning                                       |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_ARCHIVE             | A file or directory that is an archive file   |
//  | 0x00000020                         | or directory. Applications typically use this |
//  |                                    | attribute to mark files for backup or         |
//  |                                    | removal.                                      |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_COMPRESSED          | A file or directory that is compressed.       |
//  | 0x00000800                         | For a file, all of the data in the file is    |
//  |                                    | compressed. For a directory, compression is   |
//  |                                    | the default for newly created files and       |
//  |                                    | subdirectories.                               |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_DIRECTORY           | Identifies a directory.                       |
//  | 0x00000010                         |                                               |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_ENCRYPTED           | A file or directory that is encrypted.        |
//  | 0x00004000                         | For a file, all data streams in the file are  |
//  |                                    | encrypted. For a directory, encryption is     |
//  |                                    | default for newly created files and           |
//  |                                    | subdirectories.                               |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_HIDDEN              | A file or directory is hidden. It is not      |
//  | 0x00000002                         | included in an ordinary directory listing.    |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_NORMAL              | A file that does not have other attributes    |
//  | 0x00000080                         | set. set. This flag is used to clear all      |
//  |                                    | other flags by specifying it with no other    |
//  |                                    | flags set.                                    |
//  |                                    | This flag MUST be ignored if other flags are  |
//  |                                    | set.<163>                                     |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | A file or directory that is not indexed by    |
//  | 0x00002000                         | the content indexing service.                 |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_OFFLINE             | The data in this file is not available        |
//  | 0x00001000                         | immediately. This attribute indicates that    |
//  |                                    | the file data is physically moved to offline  |
//  |                                    | storage. This attribute is used by Remote     |
//  |                                    | Storage, which is hierarchical storage        |
//  |                                    | management software.                          |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_READONLY            | A file or directory that is read-only. For a  |
//  | 0x00000001                         | file, applications can read the file but      |
//  |                                    | cannot write to it or delete it. For a        |
//  |                                    | directory, applications cannot delete it, but |
//  |                                    | applications can create and delete files from |
//  |                                    | that directory.                               |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_REPARSE_POINT       | A file or directory that has an associated    |
//  | 0x00000400                         | reparse point.                                |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_SPARSE_FILE         | A file that is a sparse file.                 |
//  | 0x00000200                         |                                               |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_SYSTEM              | A file or directory that the operating system |
//  | 0x00000004                         | uses a part of, or uses exclusively.          |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_TEMPORARY           | A file or directory that is configured with   |
//  | 0x00000100                         | integrity support. For a file, all data       |
//  |                                    | streams in the file have integrity support.   |
//  |                                    | For a directory, integrity support is the     |
//  |                                    | default for newly created files and           |
//  |                                    | subdirectories, unless the caller specifies   |
//  |                                    | otherwise.<164>                               |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_INTEGRITY_STREAM    | A file or directory that is configured with   |
//  | 0x00008000                         | integrity support. For a file, all data       |
//  |                                    | streams in the file have integrity support.   |
//  |                                    | For a directory, integrity support is the     |
//  |                                    | default for newly created files and           |
//  |                                    | subdirectories, unless the caller specifies   |
//  |                                    | otherwise.<164>                               |
//  +------------------------------------+-----------------------------------------------+
//  | FILE_ATTRIBUTE_NO_SCRUB_DATA       | A file or directory that is configured to be  |
//  | 0x00020000                         | excluded from the data integrity scan. For a  |
//  |                                    | directory configured with                     |
//  |                                    | FILE_ATTRIBUTE_NO_SCRUB_DATA, the default for |
//  |                                    | newly created files and subdirectories is to  |
//  |                                    | inherit the FILE_ATTRIBUTE_NO_SCRUB_DATA      |
//  |                                    | attribute.<165>                               |
//  +------------------------------------+-----------------------------------------------+

// TODO enum class FileAttribute:uint32_t{None, Readonly, ...}
enum : uint32_t {
    FILE_ATTRIBUTE_NONE               = 0,
    FILE_ATTRIBUTE_READONLY           = 0x00000001,
    FILE_ATTRIBUTE_HIDDEN             = 0x00000002,
    FILE_ATTRIBUTE_SYSTEM             = 0x00000004,
    FILE_ATTRIBUTE_DIRECTORY          = 0x00000010,
    FILE_ATTRIBUTE_ARCHIVE            = 0x00000020,
    FILE_ATTRIBUTE_NORMAL             = 0x00000080,
    FILE_ATTRIBUTE_TEMPORARY           = 0x00000100,
    FILE_ATTRIBUTE_SPARSE_FILE         = 0x00000200,
    FILE_ATTRIBUTE_REPARSE_POINT       = 0x00000400,
    FILE_ATTRIBUTE_OFFLINE             = 0x00001000,
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000,
    FILE_ATTRIBUTE_ENCRYPTED           = 0x00004000,
    FILE_ATTRIBUTE_COMPRESSED          = 0x00000800,
    FILE_ATTRIBUTE_INTEGRITY_STREAM    = 0x00008000,
    FILE_ATTRIBUTE_NO_SCRUB_DATA       = 0x00020000
};


static inline
std::string get_FileAttributes_name(uint32_t fileAttribute) {

    std::string str;
    (fileAttribute & FILE_ATTRIBUTE_READONLY) ? str+="FILE_ATTRIBUTE_READONLY " :str;
    (fileAttribute & FILE_ATTRIBUTE_HIDDEN) ? str+="FILE_ATTRIBUTE_HIDDEN " :str;
    (fileAttribute & FILE_ATTRIBUTE_SYSTEM) ? str+="FILE_ATTRIBUTE_SYSTEM " :str;
    (fileAttribute & FILE_ATTRIBUTE_DIRECTORY) ? str+="FILE_ATTRIBUTE_DIRECTORY " : str;
    (fileAttribute & FILE_ATTRIBUTE_ARCHIVE) ? str+="FILE_ATTRIBUTE_ARCHIVE " : str;
    (fileAttribute & FILE_ATTRIBUTE_NORMAL) ? str+="FILE_ATTRIBUTE_NORMAL " : str;
    (fileAttribute & FILE_ATTRIBUTE_TEMPORARY) ? str+="FILE_ATTRIBUTE_TEMPORARY " :str;
    (fileAttribute & FILE_ATTRIBUTE_SPARSE_FILE) ? str+="FILE_ATTRIBUTE_SPARSE_FILE " : str;
    (fileAttribute & FILE_ATTRIBUTE_REPARSE_POINT) ? str+="FILE_ATTRIBUTE_REPARSE_POINT " : str;
    (fileAttribute & FILE_ATTRIBUTE_OFFLINE) ? str+="FILE_ATTRIBUTE_OFFLINE " : str;
    (fileAttribute & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED) ? str+="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED ":str;
    (fileAttribute & FILE_ATTRIBUTE_ENCRYPTED) ? str+="FILE_ATTRIBUTE_ENCRYPTED " : str;
    (fileAttribute & FILE_ATTRIBUTE_COMPRESSED) ? str+="FILE_ATTRIBUTE_COMPRESSED " : str;
    (fileAttribute & FILE_ATTRIBUTE_INTEGRITY_STREAM) ? str+="FILE_ATTRIBUTE_INTEGRITY_STREAM " : str;
    (fileAttribute & FILE_ATTRIBUTE_NO_SCRUB_DATA) ? str+="FILE_ATTRIBUTE_NO_SCRUB_DATA " : str;

    return str;
}




// 2.1.3.1 FILE_OBJECTID_BUFFER Type 1

// The first possible structure for the FILE_OBJECTID_BUFFER data element is as follows.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                      ObjectId (16 bytes)                      |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                    BirthVolumeId (16 bytes)                   |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                    BirthObjectId (16 bytes)                   |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                      DomainId (16 bytes)                      |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// ObjectId (16 bytes): A 16-byte GUID that uniquely identifies the file or directory within the volume on which it resides. Specifically, the same object ID can be assigned to another file or directory on a different volume, but it MUST NOT be assigned to another file or directory on the same volume.

// BirthVolumeId (16 bytes): A 16-byte GUID that uniquely identifies the volume on which the object resided when the object identifier was created, or zero if the volume had no object identifier at that time. After copy operations, move operations, or other file operations, this value is potentially different from the object identifier of the volume on which the object presently resides.

// BirthObjectId (16 bytes): A 16-byte GUID value containing the object identifier of the object at the time it was created. Copy operations, move operations, or other file operations MAY change the value of the ObjectId member. Therefore, the BirthObjectId is potentially different from the ObjectId member at present. Specifically, the same object ID MAY be assigned to another file or directory on a different volume, but it MUST NOT be assigned to another file or directory on the same volume. The object ID is assigned at file creation time.<5>

// DomainId (16 bytes): A 16-byte GUID value containing the domain identifier. This value is unused; it SHOULD be zero, and MUST be ignored.<6>

enum : uint32_t {
    GUID_SIZE = 16
};

struct FileObjectBuffer_Type1 {                             // FSCTL_CREATE_OR_GET_OBJECT_ID Reply struct

    uint8_t ObjectId[GUID_SIZE] = { 0 };
    uint8_t BirthVolumeId[GUID_SIZE] = { 0 };
    uint8_t BirthObjectId[GUID_SIZE] = { 0 };
    uint8_t DomainId[GUID_SIZE] = { 0 };


    FileObjectBuffer_Type1() = default;

    FileObjectBuffer_Type1(uint8_t * ObjectId, uint8_t * BirthVolumeId, uint8_t * BirthObjectId)
    {
        for (size_t i = 0; i < GUID_SIZE; i++) {
            this->ObjectId[i] = ObjectId[i];
            this->BirthVolumeId[i] = BirthVolumeId[i];
            this->BirthObjectId[i] = BirthObjectId[i];
        }
    }

    inline static size_t size() {
        return 64;   /* ObjectId(16) + BirthVolumeId(16) + */
    }                /* BirthObjectId(16) + DomainId(16)*/

    void emit(OutStream & stream) const {
        stream.out_copy_bytes(this->ObjectId, GUID_SIZE);
        stream.out_copy_bytes(this->BirthVolumeId, GUID_SIZE);
        stream.out_copy_bytes(this->BirthObjectId, GUID_SIZE);
        stream.out_copy_bytes(this->DomainId, GUID_SIZE);
    }

    void receive(InStream & stream) {
        {
            const unsigned expected = 64;   // ObjectId(16) + BirthVolumeId(16) +
                                            //     BirthObjectId(16) + DomainId(16)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileObjectBuffer_Type1: expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }
        stream.in_copy_bytes(this->ObjectId, GUID_SIZE);
        stream.in_copy_bytes(this->BirthVolumeId, GUID_SIZE);
        stream.in_copy_bytes(this->BirthObjectId, GUID_SIZE);
        stream.in_copy_bytes(this->DomainId, GUID_SIZE);
    }

    void log() const {
        LOG(LOG_INFO, "     File Object Buffer Type1:");
        LOG(LOG_INFO, "          * ObjectId       (16 bytes):");
        hexdump_c(this->ObjectId,  GUID_SIZE);
        LOG(LOG_INFO, "          * BirthVolumeId  (16 bytes):");
        hexdump_c(this->BirthVolumeId,  GUID_SIZE);
        LOG(LOG_INFO, "          * BirthObjectId  (16 bytes):");
        hexdump_c(this->BirthObjectId,  GUID_SIZE);
        LOG(LOG_INFO, "          * DomainId - (16 bytes) NOT USED");
    }
};



// 2.1.3.2 FILE_OBJECTID_BUFFER Type 2

// The second possible structure for the FILE_OBJECTID_BUFFER data element is as follows.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                      ObjectId (16 bytes)                      |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                     ExtendedInfo (48 bytes)                   |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// ObjectId (16 bytes): A 16-byte GUID that uniquely identifies the file or directory within the volume on which it resides. Specifically, the same object ID can be assigned to another file or directory on a different volume, but it MUST NOT be assigned to another file or directory on the same volume.

// ExtendedInfo (48 bytes): A 48-byte value containing extended data that was set with the FSCTL_SET_OBJECT_ID_EXTENDED request. This field contains application-specific data.<7>

struct FileObjectBuffer_Type2 {                             // FSCTL_CREATE_OR_GET_OBJECT_ID Reply struct

    uint8_t ObjectId[GUID_SIZE] = { 0 };
    uint8_t ExtendedInfo[48] = { 0 };


    const size_t ExtendedInfo_SIZE = 48;

    FileObjectBuffer_Type2() = default;

    FileObjectBuffer_Type2(uint8_t * ObjectId, uint8_t * ExtendedInfo)
    {
        for (size_t i = 0; i < GUID_SIZE; i++) {
            this->ObjectId[i] = ObjectId[i];
        }

        for (size_t i = 0; i < this->ExtendedInfo_SIZE; i++) {
            this->ExtendedInfo[i] = ExtendedInfo[i];
        }
    }

    inline static size_t size() {
        return 64;   /* ObjectId(16) + ExtendedInfo(48)*/
    }

    void emit(OutStream & stream) const {
        stream.out_copy_bytes(this->ObjectId, GUID_SIZE);
        stream.out_copy_bytes(this->ExtendedInfo, this->ExtendedInfo_SIZE);
    }

    void receive(InStream & stream) {
        {
            const unsigned expected = 64;   //  ObjectId(16) + ExtendedInfo(48)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileObjectBuffer_Type1: expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }
        stream.in_copy_bytes(this->ObjectId, GUID_SIZE);
        stream.in_copy_bytes(this->ExtendedInfo, this->ExtendedInfo_SIZE);
    }

    void log() const {
        LOG(LOG_INFO, "     File Object Buffer Type2:");
        LOG(LOG_INFO, "          * ObjectId     (16 bytes):");
        hexdump_c(this->ObjectId,  GUID_SIZE);
        LOG(LOG_INFO, "          * ExtendedInfo (48 bytes):");
        hexdump_c(this->ExtendedInfo,  this->ExtendedInfo_SIZE);
    }
};




// 2.3.5 FSCTL_DELETE_REPARSE_POINT Request
//
// This message requests that the server delete the reparse point from the file or directory associated with the handle on which this FSCTL was invoked. The underlying file or directory MUST NOT be deleted.
//
// The message MUST contain a REPARSE_GUID_DATA_BUFFER or a REPARSE_DATA_BUFFER (including subtypes) data element. Both the REPARSE_GUID_DATA_BUFFER and the REPARSE_DATA_BUFFER structures begin with a ReparseTag field. The ReparseTag value uniquely identifies the filter driver that creates/uses the reparse point, and the application's filter driver processes the reparse point data as either a REPARSE_GUID_DATA_BUFFER or a REPARSE_DATA_BUFFER, depending on the structure implemented by the filter driver for that type of reparse point.
//
// This message MUST only be sent for a file or directory handle.


// 2.1.2.3 REPARSE_GUID_DATA_BUFFER
//
// The REPARSE_GUID_DATA_BUFFER data element stores data for a reparse point and associates a GUID with the reparse tag. This reparse data buffer MUST be used only with reparse tag values whose high bit is set to 0.
//
// Reparse point GUIDs are assigned by the independent software vendor (ISV). An ISV MUST link one GUID to each assigned reparse point tag, and MUST always use that GUID with that tag.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                           ReparseTag                          |
// +-------------------------------+-------------------------------+
// |       ReparseDataLength       |           Reserved            |
// +-------------------------------+-------------------------------+
// |                     ReparseGuid (16 bytes)                    |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                     DataBuffer (variable)                     |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// ReparseTag (4 bytes): A 32-bit unsigned integer value containing the reparse point tag that uniquely identifies the owner of the reparse point.
//
// ReparseDataLength (2 bytes): A 16-bit unsigned integer value containing the size, in bytes, of the reparse data in the DataBuffer member.
//
// Reserved (2 bytes): A 16-bit field. This field SHOULD be set to 0 by the client, and MUST be ignored by the server.
//
// ReparseGuid (16 bytes): A 16-byte GUID that uniquely identifies the owner of the reparse point. Reparse point GUIDs are not assigned by Microsoft. A reparse point implementer MUST select one GUID to be used with their assigned reparse point tag to uniquely identify that reparse point. For more information, see [REPARSE].
//
// DataBuffer (variable): The content of this buffer is opaque to the file system. On receipt, its content MUST be preserved and properly returned to the caller.

struct ReparseGUIDDataBuffer {

  uint32_t ReparseTag = 0;
  uint16_t ReparseDataLength = 0;
  uint8_t ReparseGuid[GUID_SIZE] = { 0 };

  std::string DataBuffer;

  ReparseGUIDDataBuffer() = default;

  ReparseGUIDDataBuffer(uint32_t ReparseTag, uint16_t ReparseDataLength, uint8_t * ReparseGuid, uint8_t * DataBuffer)
    : ReparseTag(ReparseTag)
    , ReparseDataLength(ReparseDataLength)
    , DataBuffer(reinterpret_cast<char *>(DataBuffer), ReparseDataLength)
    {
        for (size_t i = 0; i < GUID_SIZE; i++) {
            this->ReparseGuid[i] = ReparseGuid[i];
        }
    }

    inline static size_t size() {
        return 22;   /* ReparseTag(4) + ReparseDataLength(2) + */
    }                /* ReparseGuid(16)*/

    void emit(OutStream & stream) const {
        stream.out_uint32_le(this->ReparseTag);
        stream.out_uint16_le(this->ReparseDataLength);
        stream.out_clear_bytes(2);
        stream.out_copy_bytes(this->ReparseGuid, GUID_SIZE);
        stream.out_copy_bytes(reinterpret_cast<const uint8_t *>(this->DataBuffer.data()), this->ReparseDataLength);
    }

    void receive(InStream & stream) {
        {
            const unsigned expected = 22;   //  ReparseTag(4) + ReparseDataLength(2) +
                                            //      ReparseGuid(16

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileObjectBuffer_Type1: expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }
        this->ReparseTag = stream.in_uint32_le();
        this->ReparseDataLength = stream.in_uint16_le();
        stream.in_skip_bytes(2);
        stream.in_copy_bytes(this->ReparseGuid, GUID_SIZE);
        uint8_t data[0xffff];
        stream.in_copy_bytes(data, this->ReparseDataLength);
        this->DataBuffer = std::string(reinterpret_cast<char *>(data), this->ReparseDataLength);
    }

    void log() const {
        LOG(LOG_INFO, "     Reparse GUID Data Buffer:");
        LOG(LOG_INFO, "          * ReparseTag        = 0x%08x (4 bytes)", this->ReparseTag);
        LOG(LOG_INFO, "          * ReparseDataLength = %d (4 bytes)", int(this->ReparseDataLength));
        LOG(LOG_INFO, "          * Reserved - (2 bytes) NOT USED");
        LOG(LOG_INFO, "          * ReparseGuid (16 bytes):");
        hexdump_c(this->ReparseGuid,  GUID_SIZE);
        LOG(LOG_INFO, "          * DataBuffer (%d bytes):", int(this->ReparseDataLength));
        hexdump_c(this->DataBuffer.data(),  this->ReparseDataLength);
    }
};






// [MS-FSCC] - 2.4.4 FileAllocationInformation
// ===========================================

// This information class is used to set but not to query the allocation size
//  for a file. The file system is passed a 64-bit signed integer containing
//  the file allocation size, in bytes. The file system rounds the requested
//  allocation size up to an integer multiple of the cluster size for
//  nonresident files, or an implementation-defined multiple for resident
//  files.<86><87> All unused allocation (beyond EOF) is freed on the last
//  handle close.

// A FILE_ALLOCATION_INFORMATION data element, defined as follows, is
//  provided by the client.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                         AllocationSize                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// AllocationSize (8 bytes): A 64-bit signed integer that contains the
//  desired allocation to be used by the given file.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INVALID_PARAMETER    | The handle is for a directory and not a    |
//  | 0xC000000D                  | file, or the allocation is greater than    |
//  |                             | the maximum file size allowed.             |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_ACCESS_DENIED        | The handle was not opened to write file    |
//  | 0xC0000022                  | data or file attributes.                   |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_DISK_FULL            | The disk is full.                          |
//  | 0xC000007F                  |                                            |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

struct FileAllocationInformation {

    uint64_t AllocationSize = 0;

    FileAllocationInformation() = default;

    FileAllocationInformation(uint64_t AllocationSize)
    : AllocationSize(AllocationSize)
    {}

    void emit(OutStream & stream) const {
        stream.out_uint64_le(this->AllocationSize);
    }

    void receive(InStream & stream) {
        this->AllocationSize = stream.in_uint64_le();
    }

    void log() const {
        LOG(LOG_INFO, "     File Allocation Information:");
        LOG(LOG_INFO, "          * VolumeCreationTime = 0x%" PRIu64 " (8 bytes)", this->AllocationSize);
    }
};




// [MS-FSCC] - 2.4.6 FileAttributeTagInformation
// =============================================

// This information class is used to query for attribute and reparse tag
//  information for a file.

// A FILE_ATTRIBUTE_TAG_INFORMATION data element, defined as follows, is
//  returned by the server.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                         FileAttributes                        |
// +---------------------------------------------------------------+
// |                           ReparseTag                          |
// +---------------------------------------------------------------+

// FileAttributes (4 bytes): A 32-bit unsigned integer that contains the file
//  attributes. Valid file attributes are as specified in section 2.6.

// ReparseTag (4 bytes): A 32-bit unsigned integer that specifies the reparse
//  point tag. If the FileAttributes member includes the
//  FILE_ATTRIBUTE_REPARSE_POINT attribute flag, this member specifies the
//  reparse tag. Otherwise, this member SHOULD be set to 0, and MUST be
//  ignored. Section 2.1.2.1 contains more details on reparse tags.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_ACCESS_DENIED        | The handle was not opened to read file     |
//  | 0xC0000022                  | data or file attributes.                   |
//  +-----------------------------+--------------------------------------------+

class FileAttributeTagInformation {
    uint32_t FileAttributes = 0;
    uint32_t ReparseTag     = 0;

public:
    FileAttributeTagInformation() = default;

    FileAttributeTagInformation(uint32_t FileAttributes, uint32_t ReparseTag)
    : FileAttributes(FileAttributes)
    , ReparseTag(ReparseTag) {}

    inline void emit(OutStream & stream) const {
        stream.out_uint32_le(this->FileAttributes);
        stream.out_uint32_le(this->ReparseTag);
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = 8;    // FileAttributes(4) + ReparseTag(4)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileAttributeTagInformation: expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->FileAttributes = stream.in_uint32_le();
        this->ReparseTag     = stream.in_uint32_le();
    }

    inline static size_t size() {
        return 8;   /* FileAttributes(4) + ReparseTag(4) */
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileAttributeTagInformation: FileAttributes=0x%X ReparseTag=%u",
            this->FileAttributes, this->ReparseTag);
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Attribute Tag Information:");
        LOG(LOG_INFO, "          * FileAttributes = 0x%08x (4 bytes): %s", this->FileAttributes, get_FileAttributes_name(this->FileAttributes));
        LOG(LOG_INFO, "          * ReparseTag     = 0x%08x (4 bytes)", this->ReparseTag);
    }
};


// [MS-FSCC] - 2.4.7 FileBasicInformation
// ======================================

// This information class is used to query or set file information.

// A FILE_BASIC_INFORMATION data element, defined as follows, is returned by
//  the server or provided by the client.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                          CreationTime                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         LastAccessTime                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         LastWriteTime                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                           ChangeTime                          |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         FileAttributes                        |
// +---------------------------------------------------------------+
// |                            Reserved                           |
// +---------------------------------------------------------------+

// CreationTime (8 bytes): The time when the file was created; see section
//  2.1.1. A valid time for this field is an integer greater than or equal to
//  0. When setting file attributes, a value of 0 indicates to the server
//  that it MUST NOT change this attribute. When setting file attributes, a
//  value of -1 indicates to the server that it MUST NOT change this
//  attribute for all subsequent operations on the same file handle. This
//  field MUST NOT be set to a value less than -1.

// LastAccessTime (8 bytes): The last time the file was accessed; see section
//  2.1.1. A valid time for this field is an integer greater than or equal to
//  0. When setting file attributes, a value of 0 indicates to the server
//  that it MUST NOT change this attribute. When setting file attributes, a
//  value of -1 indicates to the server that it MUST NOT change this
//  attribute for all subsequent operations on the same file handle. This
//  field MUST NOT be set to a value less than -1.<89>

// LastWriteTime (8 bytes): The last time information was written to the
//  file; see section 2.1.1. A valid time for this field is an integer
//  greater than or equal to 0. When setting file attributes, a value of 0
//  indicates to the server that it MUST NOT change this attribute. When
//  setting file attributes, a value of -1 indicates to the server that it
//  MUST NOT change this attribute for all subsequent operations on the same
//  file handle. This field MUST NOT be set to a value less than -1.<90>

// ChangeTime (8 bytes): The last time the file was changed; see section
//  2.1.1. A valid time for this field is an integer greater than or equal to
//  0. When setting file attributes, a value of 0 indicates to the server
//  that it MUST NOT change this attribute. When setting file attributes, a
//  value of -1 indicates to the server that it MUST NOT change this
//  attribute for all subsequent operations on the same file handle. This
//  field MUST NOT be set to a value less than -1.<91>

// FileAttributes (4 bytes): A 32-bit unsigned integer that contains the file
//  attributes. Valid file attributes are specified in section 2.6.

// Reserved (4 bytes): A 32-bit field. This field is reserved. This field can
//  be set to any value, and MUST be ignored.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_ACCESS_DENIED        | The handle was not opened to read file     |
//  | 0xC0000022                  | data or file attributes.                   |
//  +-----------------------------+--------------------------------------------+

class FileBasicInformation {
    uint64_t CreationTime    = 0;
    uint64_t LastAccessTime_ = 0;
    uint64_t LastWriteTime_  = 0;
    uint64_t ChangeTime      = 0;
    uint32_t FileAttributes_ = 0;

public:
    FileBasicInformation() = default;

    FileBasicInformation(uint64_t CreationTime, uint64_t LastAccessTime,
                         uint64_t LastWriteTime, uint64_t ChangeTime,
                         uint32_t FileAttributes)
    : CreationTime(CreationTime)
    , LastAccessTime_(LastAccessTime)
    , LastWriteTime_(LastWriteTime)
    , ChangeTime(ChangeTime)
    , FileAttributes_(FileAttributes) {}

    inline void emit(OutStream & stream) const {
        stream.out_uint64_le(this->CreationTime);
        stream.out_uint64_le(this->LastAccessTime_);
        stream.out_uint64_le(this->LastWriteTime_);
        stream.out_uint64_le(this->ChangeTime);

        stream.out_uint32_le(this->FileAttributes_);

        //stream.out_clear_bytes(2);
        // Reserved(4), MUST NOT be transmitted.
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = 36;   // CreationTime(8) + LastAccessTime(8) +
                                            //     LastWriteTime(8) + ChangeTime(8) +
                                            //     FileAttributes(4)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileBasicInformation: expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->CreationTime    = stream.in_uint64_le();
        this->LastAccessTime_ = stream.in_uint64_le();
        this->LastWriteTime_  = stream.in_uint64_le();
        this->ChangeTime      = stream.in_uint64_le();

        this->FileAttributes_ = stream.in_uint32_le();

        // Reserved(4), MUST NOT be transmitted.
    }

    inline uint64_t FileAttributes() const { return this->FileAttributes_; }

    inline uint64_t LastAccessTime() const { return this->LastAccessTime_; }

    inline uint64_t LastWriteTime() const { return this->LastWriteTime_; }

    inline static size_t size() {
        return 36;  /* CreationTime(8) + LastAccessTime(8) + LastWriteTime(8) + ChangeTime(8) + FileAttributes(4) */
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileBasicInformation: CreationTime=%" PRIu64 " LastAccessTime=%" PRIu64
                " LastWriteTime=%" PRIu64 " ChangeTime=%" PRIu64 " FileAttributes=0x%X",
            this->CreationTime, this->LastAccessTime_, this->LastWriteTime_,
            this->ChangeTime, this->FileAttributes_);
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Basic Information:");
        LOG(LOG_INFO, "          * CreationTime   = 0x%" PRIx64 " (8 bytes)", this->CreationTime);
        LOG(LOG_INFO, "          * LastAccessTime = 0x%" PRIx64 " (8 bytes)", this->LastAccessTime_);
        LOG(LOG_INFO, "          * LastWriteTime  = 0x%" PRIx64 " (8 bytes)", this->LastWriteTime_);
        LOG(LOG_INFO, "          * ChangeTime     = 0x%" PRIx64 " (8 bytes)", this->ChangeTime);
        LOG(LOG_INFO, "          * FileAttributes = 0x%08x (4 bytes): %s", this->FileAttributes_, get_FileAttributes_name(this->FileAttributes_));
    }
};  // FileBasicInformation

// [MS-FSCC] - 2.4.8 FileBothDirectoryInformation
// ==============================================

// This information class is used in directory enumeration to return detailed
//  information about the contents of a directory.

// This information class returns a list that contains a
//  FILE_BOTH_DIR_INFORMATION data element for each file or directory within
//  the target directory. This list MUST reflect the presence of a
//  subdirectory named "." (synonymous with the target directory itself)
//  within the target directory and one named ".." (synonymous with the
//  parent directory of the target directory). For more details, see section
//  2.1.5.1.

// This information class differs from FileDirectoryInformation (section
//  2.4.10) in that it includes short names in the returns list.

// When multiple FILE_BOTH_DIR_INFORMATION data elements are present in the
//  buffer, each MUST be aligned on an 8-byte boundary. Any bytes inserted
//  for alignment SHOULD be set to zero, and the receiver MUST ignore them.
//  No padding is required following the last data element.

// A FILE_BOTH_DIR_INFORMATION data element is as follows.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                        NextEntryOffset                        |
// +---------------------------------------------------------------+
// |                           FileIndex                           |
// +---------------------------------------------------------------+
// |                          CreationTime                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         LastAccessTime                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         LastWriteTime                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                           ChangeTime                          |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                           EndOfFile                           |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         AllocationSize                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         FileAttributes                        |
// +---------------------------------------------------------------+
// |                         FileNameLength                        |
// +---------------------------------------------------------------+
// |                             EaSize                            |
// +---------------+---------------+-------------------------------+
// |ShortNameLength|    Reserved   |           ShortName           |
// +---------------+---------------+-------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                              ...                              |
// +-------------------------------+-------------------------------+
// |              ...              |      FileName (variable)      |
// +-------------------------------+-------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// NextEntryOffset (4 bytes): A 32-bit unsigned integer that contains the
//  byte offset from the beginning of this entry, at which the next
//  FILE_BOTH_DIR_INFORMATION entry is located, if multiple entries are
//  present in a buffer. This member is zero if no other entries follow this
//  one. An implementation MUST use this value to determine the location of
//  the next entry (if multiple entries are present in a buffer).

// FileIndex (4 bytes): A 32-bit unsigned integer that contains the byte
//  offset of the file within the parent directory. For file systems in which
//  the position of a file within the parent directory is not fixed and can
//  be changed at any time to maintain sort order, this field SHOULD be set
//  to 0x00000000 and MUST be ignored.<92>

// CreationTime (8 bytes): The time when the file was created; see section
//  2.1.1. This value MUST be greater than or equal to 0.

// LastAccessTime (8 bytes): The last time the file was accessed; see section
//  2.1.1. This value MUST be greater than or equal to 0.

// LastWriteTime (8 bytes): The last time information was written to the
//  file; see section 2.1.1. This value MUST be greater than or equal to 0.

// ChangeTime (8 bytes): The last time the file was changed; see section
//  2.1.1. This value MUST be greater than or equal to 0.

// EndOfFile (8 bytes): A 64-bit signed integer that contains the absolute
//  new end-of-file position as a byte offset from the start of the file.
//  EndOfFile specifies the offset to the byte immediately following the last
//  valid byte in the file. Because this value is zero-based, it actually
//  refers to the first free byte in the file. That is, it is the offset from
//  the beginning of the file at which new bytes appended to the file will be
//  written. The value of this field MUST be greater than or equal to 0.

// AllocationSize (8 bytes): A 64-bit signed integer that contains the file
//  allocation size, in bytes. The value of this field MUST be an integer
//  multiple of the cluster size.

// FileAttributes (4 bytes): A 32-bit unsigned integer that contains the file
//  attributes. Valid file attributes are specified in section 2.6.

// FileNameLength (4 bytes): A 32-bit unsigned integer that specifies the
//  length, in bytes, of the file name contained within the FileName member.

// EaSize (4 bytes): A 32-bit unsigned integer that contains the combined
//  length, in bytes, of the extended attributes (EA) for the file.

// ShortNameLength (1 byte): An 8-bit signed integer that specifies the
//  length, in bytes, of the file name contained in the ShortName member.
//  This value MUST be greater than or equal to 0.

// Reserved (1 byte): Reserved for alignment. This field can contain any
//  value and MUST be ignored.

// ShortName (24 bytes): A sequence of Unicode characters containing the
//  short (8.3) file name. When working with this field, use ShortNameLength
//  to determine the length of the file name rather than assuming the
//  presence of a trailing null delimiter.

// FileName (variable): A sequence of Unicode characters containing the file
//  name. When working with this field, use FileNameLength to determine the
//  length of the file name rather than assuming the presence of a trailing
//  null delimiter. Dot directory names are valid for this field. For more
//  details, see section 2.1.5.1.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

class FileBothDirectoryInformation {

    uint32_t NextEntryOffset = 0;
    uint32_t FileIndex       = 0;
    uint64_t CreationTime    = 0;
    uint64_t LastAccessTime  = 0;
    uint64_t LastWriteTime   = 0;
    uint64_t ChangeTime      = 0;
    int64_t  EndOfFile       = 0;
    int64_t  AllocationSize  = 0;
    uint32_t FileAttributes  = 0;
    uint32_t EaSize          = 0;

    std::string short_name;
    std::string file_name;


public:
    enum : unsigned {
      MIN_SIZE = 93
    };

    uint32_t total_size() {
        return this->file_name.length() + MIN_SIZE;
    }

    FileBothDirectoryInformation() = default;

    FileBothDirectoryInformation(uint64_t CreationTime,
                                 uint64_t LastAccessTime,
                                 uint64_t LastWriteTime, uint64_t ChangeTime,
                                 int64_t EndOfFile, int64_t AllocationSize,
                                 uint32_t FileAttributes,
                                 const char * file_name)
    : CreationTime(CreationTime)
    , LastAccessTime(LastAccessTime)
    , LastWriteTime(LastWriteTime)
    , ChangeTime(ChangeTime)
    , EndOfFile(EndOfFile)
    , AllocationSize(AllocationSize)
    , FileAttributes(FileAttributes)
    , file_name([&file_name]() {

        uint8_t FileName_unicode_data[500];
        size_t size_utf16 = ::UTF8toUTF16(reinterpret_cast<const uint8_t *>(file_name),
            FileName_unicode_data, sizeof(FileName_unicode_data));

        const std::string str(reinterpret_cast<char *>(FileName_unicode_data), size_utf16);

        return str;
    }())
      {}

    inline void emit(OutStream & stream) const {
        stream.out_uint32_le(this->NextEntryOffset);
        stream.out_uint32_le(this->FileIndex);

        stream.out_uint64_le(this->CreationTime);
        stream.out_uint64_le(this->LastAccessTime);
        stream.out_uint64_le(this->LastWriteTime);
        stream.out_uint64_le(this->ChangeTime);

        stream.out_sint64_le(this->EndOfFile);
        stream.out_sint64_le(this->AllocationSize);

        stream.out_uint32_le(this->FileAttributes);

        stream.out_uint32_le(this->file_name.length());         // FileNameLength(4)

        stream.out_uint32_le(this->EaSize);

        REDASSERT(this->short_name.length() <= 24 /* ShortName(24) */);

        stream.out_sint8(this->short_name.length());             // ShortNameLength(1)

        // Reserved(1), MUST NOT be transmitted.

        stream.out_copy_bytes(this->short_name.data(), this->short_name.length());
        if (this->short_name.length() < 24  /* ShortName(24) */) {
            stream.out_clear_bytes(24 /* ShortName(24) */ - this->short_name.length());
        }

        stream.out_copy_bytes(this->file_name.data(), this->file_name.length());
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = MIN_SIZE;   // NextEntryOffset(4) + FileIndex(4) +
                                                  //     CreationTime(8) + LastAccessTime(8) +
                                                  //     LastWriteTime(8) + ChangeTime(8) +
                                                  //     EndOfFile(8) + AllocationSize(8) +
                                                  //     FileAttributes(4) + FileNameLength(4) +
                                                  //     EaSize(4) + ShortNameLength(1) +
                                                  //     ShortName(24)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileBothDirectoryInformation (0): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->NextEntryOffset = stream.in_uint32_le();
        this->FileIndex       = stream.in_uint32_le();
        this->CreationTime    = stream.in_uint64_le();
        this->LastAccessTime  = stream.in_uint64_le();
        this->LastWriteTime   = stream.in_uint64_le();
        this->ChangeTime      = stream.in_uint64_le();
        this->EndOfFile       = stream.in_sint64_le();
        this->AllocationSize  = stream.in_sint64_le();
        this->FileAttributes  = stream.in_uint32_le();

        uint32_t FileNameLength = stream.in_uint32_le();

        this->EaSize = stream.in_uint32_le();

        uint8_t ShortNameLength = stream.in_sint8();

        // Reserved(1), MUST NOT be transmitted.

        uint8_t const * const ShortName = stream.get_current();
//         uint8_t ShortName_utf8_string[24 /*ShortName(24)*/ * maximum_length_of_utf8_character_in_bytes];
//         const size_t length_of_ShortName_utf8_string = ::UTF16toUTF8(
//             ShortName, ShortNameLength / 2, ShortName_utf8_string,
//             sizeof(ShortName_utf8_string));
        this->short_name.assign(::char_ptr_cast(ShortName),
            ShortNameLength);

        stream.in_skip_bytes(24);   // ShortName(24)

        {
            const unsigned expected = FileNameLength;   // FileName(variable)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileBothDirectoryInformation (1): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_RDPDR_PDU_TRUNCATED);
            }
        }

        uint8_t const * const FileName_unicode_data = stream.get_current();
//         uint8_t FileName_utf8_string[1024 * 64 / sizeof(uint16_t) * maximum_length_of_utf8_character_in_bytes];
//         const size_t length_of_FileName_utf8_string = ::UTF16toUTF8(
//             FileName_unicode_data, FileNameLength / 2, FileName_utf8_string,
//             sizeof(FileName_utf8_string));
        this->file_name.assign(::char_ptr_cast(FileName_unicode_data),
            FileNameLength);

        stream.in_skip_bytes(FileNameLength);
    }

    inline size_t size() const {
        size_t size = 93;   // NextEntryOffset(4) + FileIndex(4) +
                            //     CreationTime(8) + LastAccessTime(8) +
                            //     LastWriteTime(8) + ChangeTime(8) +
                            //     EndOfFile(8) + AllocationSize(8) +
                            //     FileAttributes(4) + FileNameLength(4) +
                            //     EaSize(4) + ShortNameLength(1) +
                            //     ShortName(24)

        // Reserved(1), MUST NOT be transmitted.

        uint8_t unicode_data[65536];
        size_t size_of_unicode_data = ::UTF8toUTF16(
            reinterpret_cast<const uint8_t *>(this->file_name.c_str()),
            unicode_data, sizeof(unicode_data));

        return size + size_of_unicode_data;
    }

    std::string FileName() const {
        uint8_t FileName_utf8_string[500];
        const size_t length_of_FileName_utf8_string = ::UTF16toUTF8(
            reinterpret_cast<const uint8_t*>(this->file_name.data()), this->file_name.length() / 2, FileName_utf8_string,
            sizeof(FileName_utf8_string));

        return std::string(reinterpret_cast<char*>(FileName_utf8_string), length_of_FileName_utf8_string);
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileBothDirectoryInformation: NextEntryOffset=%u FileIndex=%u CreationTime=%" PRIu64
                " LastAccessTime=%" PRIu64 " LastWriteTime=%" PRIu64 " ChangeTime=%" PRIu64
                " EndOfFile=%" PRId64 " AllocationSize=%" PRId64 " FileAttributes=0x%X "
                "EaSize=%u ShortName=\"%s\" FileName=\"%s\"",
            this->NextEntryOffset, this->FileIndex,
            this->CreationTime, this->LastAccessTime, this->LastWriteTime,
            this->ChangeTime, this->EndOfFile, this->AllocationSize, this->FileAttributes,
            this->EaSize, this->short_name.c_str(), this->file_name.c_str());
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Both Directory Information:");
        LOG(LOG_INFO, "          * NextEntryOffset = 0x%08x (4 bytes)", this->NextEntryOffset);
        LOG(LOG_INFO, "          * FileIndex       = 0x%08x (4 bytes)", this->FileIndex);
        LOG(LOG_INFO, "          * CreationTime    = 0x%" PRIx64 " (8 bytes)", this->CreationTime);
        LOG(LOG_INFO, "          * LastAccessTime  = 0x%" PRIx64 " (8 bytes)", this->LastAccessTime);
        LOG(LOG_INFO, "          * LastWriteTime   = 0x%" PRIx64 " (8 bytes)", this->LastWriteTime);
        LOG(LOG_INFO, "          * ChangeTime      = 0x%" PRIx64 " (8 bytes)", this->ChangeTime);
        LOG(LOG_INFO, "          * EndOfFile       = 0x%" PRIx64 " (8 bytes)", this->EndOfFile);
        LOG(LOG_INFO, "          * AllocationSize  = 0x%" PRIx64 " (8 bytes)", this->AllocationSize);
        LOG(LOG_INFO, "          * FileAttributes  = 0x%08x (4 bytes): %s", this->FileAttributes, get_FileAttributes_name(this->FileAttributes));
        LOG(LOG_INFO, "          * FileNameLength  = %zu (4 bytes)", this->file_name.length());
        LOG(LOG_INFO, "          * EaSize          = %u (4 bytes)", this->EaSize);
        LOG(LOG_INFO, "          * ShortNameLength = %zu (1 byte)", this->short_name.length());
        LOG(LOG_INFO, "          * Reserved - (1 byte) NOT USED");
        LOG(LOG_INFO, "          * short_name      = \"%s\" (24 bytes)", this->short_name);
        LOG(LOG_INFO, "          * FileName        = \"%s\" (%zu byte(s))", this->FileName(), this->FileName().length());
    }
};  // FileBothDirectoryInformation



// 2.4.10 FileDirectoryInformation

// This information class is used in directory enumeration to return detailed information about the contents of a directory.

// This information class returns a list that contains a FILE_DIRECTORY_INFORMATION data element for each file or directory within the target directory. This list MUST reflect the presence of a subdirectory named "." (synonymous with the target directory itself) within the target directory and one named ".." (synonymous with the parent directory of the target directory). For more details, see section 2.1.5.1.

// When multiple FILE_DIRECTORY_INFORMATION data elements are present in the buffer, each MUST be aligned on an 8-byte boundary. Any bytes inserted for alignment SHOULD be set to zero, and the receiver MUST ignore them. No padding is required following the last data element.

// A FILE_DIRECTORY_INFORMATION data element is as follows.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                        NextEntryOffset                        |
// +---------------------------------------------------------------+
// |                           FileIndex                           |
// +---------------------------------------------------------------+
// |                          CreationTime                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         LastAccessTime                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         LastWriteTime                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                           ChangeTime                          |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                           EndOfFile                           |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         AllocationSize                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         FileAttributes                        |
// +---------------------------------------------------------------+
// |                         FileNameLength                        |
// +---------------------------------------------------------------+
// |                       FileName (variable)                     |
// +---------------+---------------+-------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// NextEntryOffset (4 bytes):  A 32-bit unsigned integer that contains the byte offset from the beginning of this entry, at which the next FILE_DIRECTORY_INFORMATION entry is located, if multiple entries are present in a buffer. This member MUST be zero if no other entries follow this one. An implementation MUST use this value to determine the location of the next entry (if multiple entries are present in a buffer).

// FileIndex (4 bytes):  A 32-bit unsigned integer that contains the byte offset of the file within the parent directory. For file systems in which the position of a file within the parent directory is not fixed and can be changed at any time to maintain sort order, this field SHOULD be set to 0 and MUST be ignored.<100>

// CreationTime (8 bytes):  The time when the file was created; see section 2.1.1. This value MUST be greater than or equal to 0.

// LastAccessTime (8 bytes):  The last time the file was accessed; see section 2.1.1. This value MUST be greater than or equal to 0.

// LastWriteTime (8 bytes):  The last time information was written to the file; see section 2.1.1. This value MUST be greater than or equal to 0.

// ChangeTime (8 bytes):  The last time the file was changed; see section 2.1.1. This value MUST be greater than or equal to 0.

// EndOfFile (8 bytes):  A 64-bit signed integer that contains the absolute new end-of-file position as a byte offset from the start of the file. EndOfFile specifies the offset to the byte immediately following the last valid byte in the file. Because this value is zero-based, it actually refers to the first free byte in the file. That is, it is the offset from the beginning of the file at which new bytes appended to the file will be written. The value of this field MUST be greater than or equal to 0.

// AllocationSize (8 bytes):  A 64-bit signed integer that contains the file allocation size, in bytes. The value of this field MUST be an integer multiple of the cluster size.

// FileAttributes (4 bytes):  A 32-bit unsigned integer that contains the file attributes. Valid attributes are as specified in section 2.6.

// FileNameLength (4 bytes):  A 32-bit unsigned integer that specifies the length, in bytes, of the file name contained within the FileName member.

// FileName (variable): A sequence of Unicode characters containing the file name. When working with this field, use FileNameLength to determine the length of the file name rather than assuming the presence of a trailing null delimiter. Dot directory names are valid for this field. For more details, see section 2.1.5.1.

// This operation returns a status code, as specified in [MS-ERREF] section 2.3. The status code returned directly by the function that processes this file information class MUST be STATUS_SUCCESS or one of the following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

class FileDirectoryInformation {

    uint32_t NextEntryOffset = 0;
    uint32_t FileIndex       = 0;
    uint64_t CreationTime    = 0;
    uint64_t LastAccessTime_ = 0;
    uint64_t LastWriteTime_  = 0;
    uint64_t ChangeTime      = 0;
    uint64_t EndOfFile       = 0;
    uint64_t AllocationSize  = 0;
    uint32_t FileAttributes_ = 42;
    std::string File_Name;

public:
    enum : unsigned {
        MIN_SIZE = 64
    };

    uint32_t total_size() {
        return this->File_Name.size() + MIN_SIZE;
    }

    FileDirectoryInformation() = default;

    FileDirectoryInformation(uint32_t NextEntryOffset, uint32_t FileIndex,
                             uint64_t CreationTime, uint64_t LastAccessTime,
                             uint64_t LastWriteTime, uint64_t ChangeTime,
                             uint32_t FileAttributes, std::string FileName)
    : NextEntryOffset(NextEntryOffset)
    , FileIndex(FileIndex)
    , CreationTime(CreationTime)
    , LastAccessTime_(LastAccessTime)
    , LastWriteTime_(LastWriteTime)
    , ChangeTime(ChangeTime)
    , FileAttributes_(FileAttributes)
    , File_Name([&FileName]() {

        uint8_t FileName_unicode_data[500];
        size_t size_utf16 = ::UTF8toUTF16(reinterpret_cast<const uint8_t *>(FileName.c_str()),
            FileName_unicode_data, sizeof(FileName_unicode_data));

        const std::string str(reinterpret_cast<char *>(FileName_unicode_data), size_utf16);

        return str;
    }())
    {}

    void emit(OutStream & stream) const {
        stream.out_uint32_le(this->NextEntryOffset);
        stream.out_uint32_le(this->FileIndex);

        stream.out_uint64_le(this->CreationTime);
        stream.out_uint64_le(this->LastAccessTime_);
        stream.out_uint64_le(this->LastWriteTime_);
        stream.out_uint64_le(this->ChangeTime);
        stream.out_uint64_le(this->EndOfFile);
        stream.out_uint64_le(this->AllocationSize);
        stream.out_uint32_le(this->FileAttributes_);

        stream.out_uint32_le(this->File_Name.size());

        stream.out_copy_bytes(reinterpret_cast<const uint8_t *>(this->File_Name.data()), this->File_Name.size());
    }

    void receive(InStream & stream) {

        {
            const unsigned expected = MIN_SIZE; // NextEntryOffset(4) + FileIndex(4) +
                                                //     CreationTime(8) + LastAccessTime(8) +
                                                //     LastWriteTime(8) + ChangeTime(8) +
                                                //     EndOfFile(8) + AllocationSize(8) +
                                                //     FileAttributes(4) + FileNameLength(4)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileBothDirectoryInformation (0): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->NextEntryOffset = stream.in_uint32_le();
        this->FileIndex       = stream.in_uint32_le();

        this->CreationTime    = stream.in_uint64_le();
        this->LastAccessTime_ = stream.in_uint64_le();
        this->LastWriteTime_  = stream.in_uint64_le();
        this->ChangeTime      = stream.in_uint64_le();

        this->EndOfFile       = stream.in_uint64_le();
        this->AllocationSize  = stream.in_uint64_le();

        this->FileAttributes_ = stream.in_uint32_le();

        size_t size = stream.in_uint32_le();

        this->File_Name.assign(::char_ptr_cast(stream.get_current()),
            size);

        stream.in_skip_bytes(size);
    }

    inline uint64_t FileAttributes() const { return this->FileAttributes_; }

    inline uint64_t LastAccessTime() const { return this->LastAccessTime_; }

    inline uint64_t LastWriteTime() const { return this->LastWriteTime_; }

    std::string FileName() const {
        uint8_t FileName_utf8_string[500];
        const size_t length_of_FileName_utf8_string = ::UTF16toUTF8(
            reinterpret_cast<const uint8_t*>(this->File_Name.data()), this->File_Name.length() / 2, FileName_utf8_string,
            sizeof(FileName_utf8_string));

        return std::string(reinterpret_cast<char*>(FileName_utf8_string), length_of_FileName_utf8_string);
    }

    void log() const {
        LOG(LOG_INFO, "     File Directory Information:");
        LOG(LOG_INFO, "          * NextEntryOffset = 0x%08x (4 bytes)", this->NextEntryOffset);
        LOG(LOG_INFO, "          * FileIndex       = 0x%08x (4 bytes)", this->FileIndex);
        LOG(LOG_INFO, "          * CreationTime    = 0x%" PRIx64 " (8 bytes)", this->CreationTime);
        LOG(LOG_INFO, "          * LastAccessTime  = 0x%" PRIx64 " (8 bytes)", this->LastAccessTime_);
        LOG(LOG_INFO, "          * LastWriteTime   = 0x%" PRIx64 " (8 bytes)", this->LastWriteTime_);
        LOG(LOG_INFO, "          * ChangeTime      = 0x%" PRIx64 " (8 bytes)", this->ChangeTime);
        LOG(LOG_INFO, "          * FileAttributes  = 0x%08x (4 bytes): %s", this->FileAttributes_, get_FileAttributes_name(this->FileAttributes_));
        LOG(LOG_INFO, "          * FileNameLength  = %zu (4 bytes)", this->FileName().size());
        LOG(LOG_INFO, "          * FileName        = \"%s\" (%zu byte(s))", this->FileName(), this->FileName().size());
    }
};  //FileDirectoryInformation



// [MS-FSCC] - 2.4.11 FileDispositionInformation
// =============================================

// This information class is used to mark a file for deletion.

// A FILE_DISPOSITION_INFORMATION data element, defined as follows, is
//  provided by the client.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | DeletePending |
// +---------------+

// DeletePending (1 byte): An 8-bit field that is set to 1 to indicate that a
//  file SHOULD be deleted when it is closed; otherwise, 0.<98>

// For a discussion of file deletion semantics, see [FSBO].

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_ACCESS_DENIED        | The handle was not opened with delete      |
//  | 0xC0000022                  | access.                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

struct FileDispositionInformation {

    uint8_t DeletePending = 0;

    FileDispositionInformation() = default;

    FileDispositionInformation( uint64_t DeletePending)
      : DeletePending(DeletePending)
      {}

    void emit(OutStream & stream) const {
        stream.out_uint8(this->DeletePending);
    }

    void receive(InStream & stream) {
        {
            const unsigned expected = 1; // DeletePending(1)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileBothDirectoryInformation (0): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }
        this->DeletePending = stream.in_uint8();
    }

    inline static size_t size() {
        return 1;  // DeletePending(1)
    }

    void log() const {
        LOG(LOG_INFO, "     File Disposition Information:");
        LOG(LOG_INFO, "          * DeletePending = 0x%02x (1 byte)", this->DeletePending);
    }
};




// [MS-FSCC] - 2.4.13 FileEndOfFileInformation
// ===========================================

// This information class is used to set end-of-file information for a file.

// A FILE_END_OF_FILE_INFORMATION data element, defined as follows, is
//  provided by the client.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                           EndOfFile                           |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// EndOfFile (8 bytes): A 64-bit signed integer that contains the absolute
//  new end of file position as a byte offset from the start of the file.
//  EndOfFile specifies the offset from the beginning of the file of the byte
//  following the last byte in the file. That is, it is the offset from the
//  beginning of the file at which new bytes appended to the file will be
//  written. The value of this field MUST be greater than or equal to 0.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INVALID_PARAMETER    | The handle was for a directory and not a   |
//  | 0xC000000D                  | file, or the allocation is greater than    |
//  |                             | the maximum file size allowed.             |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_ACCESS_DENIED        | The handle was not opened to read file     |
//  | 0xC0000022                  | data or file attributes.                   |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_DISK_FULL            | The disk is full.                          |
//  | 0xC000007F                  |                                            |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

struct FileEndOfFileInformation {

    uint64_t EndOfFile = 0;

    FileEndOfFileInformation() = default;

    FileEndOfFileInformation( uint64_t EndOfFile)
      : EndOfFile(EndOfFile)
      {}

    void emit(OutStream & stream) const {
        stream.out_uint64_le(this->EndOfFile);
    }

    void receive(InStream & stream) {
        this->EndOfFile = stream.in_uint64_le();
    }

    void log() const {
        LOG(LOG_INFO, "     File EndOfFile Information:");
        LOG(LOG_INFO, "          * EndOfFile = 0x%" PRIx64 " (8 bytes)", this->EndOfFile);
    }
};



// 2.5.5 FileFsLabelInformation

// This information class is used locally to set the label for a file system volume.

// A FILE_FS_LABEL_INFORMATION data element, defined as follows, is provided by the caller.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                       VolumeLabelLength                       |
// +---------------------------------------------------------------+
// |                     VolumeLabel (variable)                    |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// VolumeLabelLength (4 bytes): A 32-bit unsigned integer that contains the length, in bytes, including the trailing null, if present, of the name for the volume.<150>

// VolumeLabel (variable): A variable-length Unicode field containing the name of the volume. The content of this field can be a null-terminated string, or it can be a string padded with the space character to be VolumeLabelLength bytes long.

// This operation returns a status code, as specified in [MS-ERREF] section 2.3. The status code returned directly by the function that processes this file information class MUST be STATUS_SUCCESS or one of the following.

//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

struct FileFsLabelInformation {

    std::string VolumeLabel;

    FileFsLabelInformation() = default;

    FileFsLabelInformation(std::string VolumeLabel)
      : VolumeLabel(VolumeLabel)
      {}

    void emit(OutStream & stream) const {
        stream.out_uint32_le(this->VolumeLabel.size());
        stream.out_copy_bytes(this->VolumeLabel.data(), this->VolumeLabel.size());
    }

    void receive(InStream & stream) {
        size_t size = stream.in_uint32_le();
        this->VolumeLabel = std::string(reinterpret_cast<const char *>(stream.get_current()), size);
    }

    void log() const {
        LOG(LOG_INFO, "     File Fs Label Information:");
        LOG(LOG_INFO, "          * VolumeLabelLength = %zu (4 bytes)", this->VolumeLabel.size());
        LOG(LOG_INFO, "          * VolumeLabel       = \"%s\" (%zu byte(s))", this->VolumeLabel, this->VolumeLabel.size());
    }

};


// [MS-FSCC] - 2.4.14 FileFullDirectoryInformation
// ===============================================

// This information class is used in directory enumeration to return detailed
//  information about the contents of a directory.

// This information class returns a list that contains a
//  FILE_FULL_DIR_INFORMATION data element for each file or directory within
//  the target directory. This list MUST reflect the presence of a
//  subdirectory named "." (synonymous with the target directory itself)
//  within the target directory and one named ".." (synonymous with the
//  parent directory of the target directory). For more details, see section
//  2.1.5.1.

// When multiple FILE_FULL_DIR_INFORMATION data elements are present in the
//  buffer, each MUST be aligned on an 8-byte boundary; any bytes inserted
//  for alignment SHOULD be set to zero, and the receiver MUST ignore them.
//  No padding is required following the last data element.

// A FILE_FULL_DIR_INFORMATION data element is as follows.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                        NextEntryOffset                        |
// +---------------------------------------------------------------+
// |                           FileIndex                           |
// +---------------------------------------------------------------+
// |                          CreationTime                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         LastAccessTime                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         LastWriteTime                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                           ChangeTime                          |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                           EndOfFile                           |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         AllocationSize                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         FileAttributes                        |
// +---------------------------------------------------------------+
// |                         FileNameLength                        |
// +---------------------------------------------------------------+
// |                             EaSize                            |
// +---------------------------------------------------------------+
// |                      FileName (variable)                      |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// NextEntryOffset (4 bytes): A 32-bit unsigned integer that contains the
//  byte offset from the beginning of this entry, at which the next
//  FILE_FULL_DIR_INFORMATION entry is located, if multiple entries are
//  present in a buffer. This member is zero if no other entries follow this
//  one. An implementation MUST use this value to determine the location of
//  the next entry (if multiple entries are present in a buffer).

// FileIndex (4 bytes): A 32-bit unsigned integer that contains the byte
//  offset of the file within the parent directory. For file systems such as
//  NTFS, in which the position of a file within the parent directory is not
//  fixed and can be changed at any time to maintain sort order, this field
//  SHOULD be set to 0, and MUST be ignored.<99>

// CreationTime (8 bytes): The time when the file was created; see section
//  2.1.1. This value MUST be greater than or equal to 0.

// LastAccessTime (8 bytes): The last time the file was accessed; see section
//  2.1.1. This value MUST be greater than or equal to 0.

// LastWriteTime (8 bytes): The last time information was written to the
//  file; see section 2.1.1. This value MUST be greater than or equal to 0.

// ChangeTime (8 bytes): The last time the file was changed; see section
//  2.1.1. This value MUST be greater than or equal to 0.

// EndOfFile (8 bytes): A 64-bit signed integer that contains the absolute
//  new end-of-file position as a byte offset from the start of the file.
//  EndOfFile specifies the offset to the byte immediately following the last
//  valid byte in the file. Because this value is zero-based, it actually
//  refers to the first free byte in the file. That is, it is the offset from
//  the beginning of the file at which new bytes appended to the file will be
//  written. The value of this field MUST be greater than or equal to 0.

// AllocationSize (8 bytes): A 64-bit signed integer that contains the file
//  allocation size, in bytes. The value of this field MUST be an integer
//  multiple of the cluster size.

// FileAttributes (4 bytes): A 32-bit unsigned integer that contains the file
//  attributes. For a list of valid file attributes, see section 2.6.

// FileNameLength (4 bytes): A 32-bit unsigned integer that specifies the
//  length, in bytes, of the file name contained within the FileName member.

// EaSize (4 bytes): A 32-bit unsigned integer that contains the combined
//  length, in bytes, of the extended attributes (EA) for the file.

// FileName (variable): A sequence of Unicode characters containing the file
//  name. When working with this field, use FileNameLength to determine the
//  length of the file name rather than assuming the presence of a trailing
//  null delimiter. Dot directory names are valid for this field. For more
//  details, see section 2.1.5.1.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+-----------------------------------------+
//  | Error code                  | Meaning                                 |
//  +-----------------------------+-----------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length |
//  | 0xC0000004                  | does not match the length that is       |
//  |                             | required for the specified information  |
//  |                             | class.                                  |
//  +-----------------------------+-----------------------------------------+

class FileFullDirectoryInformation {
    uint32_t NextEntryOffset = 0;
    uint32_t FileIndex       = 0;
    uint64_t CreationTime    = 0;
    uint64_t LastAccessTime  = 0;
    uint64_t LastWriteTime   = 0;
    uint64_t ChangeTime      = 0;
    int64_t  EndOfFile       = 0;
    int64_t  AllocationSize  = 0;
    uint32_t FileAttributes  = 0;
    uint32_t EaSize          = 0;

    std::string file_name;


public:
     enum : unsigned {
      MIN_SIZE = 68
    };

    uint32_t total_size() {
        return file_name.size() + MIN_SIZE;
    }

    FileFullDirectoryInformation() = default;

    FileFullDirectoryInformation(uint64_t CreationTime,
                                 uint64_t LastAccessTime,
                                 uint64_t LastWriteTime, uint64_t ChangeTime,
                                 int64_t EndOfFile, int64_t AllocationSize,
                                 uint32_t FileAttributes,
                                 const char * file_name)
    : CreationTime(CreationTime)
    , LastAccessTime(LastAccessTime)
    , LastWriteTime(LastWriteTime)
    , ChangeTime(ChangeTime)
    , EndOfFile(EndOfFile)
    , AllocationSize(AllocationSize)
    , FileAttributes(FileAttributes)
    , file_name([&file_name]() {

        uint8_t FileName_unicode_data[500];
        size_t size_utf16 = ::UTF8toUTF16(reinterpret_cast<const uint8_t *>(file_name),
            FileName_unicode_data, sizeof(FileName_unicode_data));

        const std::string str(reinterpret_cast<char *>(FileName_unicode_data), size_utf16);

        return str;
    }())
    {}

    inline void emit(OutStream & stream) const {
        stream.out_uint32_le(this->NextEntryOffset);
        stream.out_uint32_le(this->FileIndex);

        stream.out_uint64_le(this->CreationTime);
        stream.out_uint64_le(this->LastAccessTime);
        stream.out_uint64_le(this->LastWriteTime);
        stream.out_uint64_le(this->ChangeTime);

        stream.out_sint64_le(this->EndOfFile);
        stream.out_sint64_le(this->AllocationSize);

        stream.out_uint32_le(this->FileAttributes);

//         uint8_t FileName_unicode_data[65536];
//         const size_t size_of_FileName_unicode_data = ::UTF8toUTF16(
//             reinterpret_cast<const uint8_t *>(this->file_name.c_str()),
//             FileName_unicode_data, sizeof(FileName_unicode_data));

        stream.out_uint32_le(file_name.size());    // FileNameLength(4)

        stream.out_uint32_le(this->EaSize);

        stream.out_copy_bytes(file_name.data(),
            file_name.size());
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = MIN_SIZE;   // NextEntryOffset(4) + FileIndex(4) +
                                                 //     CreationTime(8) + LastAccessTime(8) +
                                                 //     LastWriteTime(8) + ChangeTime(8) +
                                                 //     EndOfFile(8) + AllocationSize(8) +
                                                 //     FileAttributes(4) + FileNameLength(4) +
                                                 //     EaSize(4)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFullDirectoryInformation (0): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->NextEntryOffset = stream.in_uint32_le();
        this->FileIndex       = stream.in_uint32_le();
        this->CreationTime    = stream.in_uint64_le();
        this->LastAccessTime  = stream.in_uint64_le();
        this->LastWriteTime   = stream.in_uint64_le();
        this->ChangeTime      = stream.in_uint64_le();
        this->EndOfFile       = stream.in_sint64_le();
        this->AllocationSize  = stream.in_sint64_le();
        this->FileAttributes  = stream.in_uint32_le();

        const uint32_t FileNameLength = stream.in_uint32_le();

        this->EaSize = stream.in_uint32_le();

        {
            const unsigned expected = FileNameLength;   // FileName(variable)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFullDirectoryInformation (1): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_RDPDR_PDU_TRUNCATED);
            }
        }

        uint8_t const * const FileName_unicode_data = stream.get_current();
//         uint8_t FileName_utf8_string[1024 * 64 / sizeof(uint16_t) * maximum_length_of_utf8_character_in_bytes];
//         const size_t length_of_FileName_utf8_string = ::UTF16toUTF8(
//             FileName_unicode_data, FileNameLength / 2, FileName_utf8_string,
//             sizeof(FileName_utf8_string));
        this->file_name.assign(::char_ptr_cast(FileName_unicode_data),
            FileNameLength);

        stream.in_skip_bytes(FileNameLength);
    }

    inline size_t size() const {
        size_t size = 68;   // NextEntryOffset(4) + FileIndex(4) +
                            //     CreationTime(8) + LastAccessTime(8) +
                            //     LastWriteTime(8) + ChangeTime(8) +
                            //     EndOfFile(8) + AllocationSize(8) +
                            //     FileAttributes(4) + FileNameLength(4) +
                            //     EaSize(4)

        return size + this->file_name.length();
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileFullDirectoryInformation: NextEntryOffset=%u FileIndex=%u CreationTime=%" PRIu64
                " LastAccessTime=%" PRIu64 " LastWriteTime=%" PRIu64 " ChangeTime=%" PRIu64
                " EndOfFile=%" PRId64 " AllocationSize=%" PRId64 " FileAttributes=0x%X "
                "EaSize=%u FileName=\"%s\"",
            this->NextEntryOffset, this->FileIndex,
            this->CreationTime, this->LastAccessTime, this->LastWriteTime,
            this->ChangeTime, this->EndOfFile, this->AllocationSize, this->FileAttributes,
            this->EaSize, this->file_name.c_str());
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Full Directory Information:");
        LOG(LOG_INFO, "          * NextEntryOffset = 0x%08x (4 bytes)", this->NextEntryOffset);
        LOG(LOG_INFO, "          * FileIndex       = 0x%08x (4 bytes)", this->FileIndex);
        LOG(LOG_INFO, "          * CreationTime    = 0x%" PRIx64 " (8 bytes)", this->CreationTime);
        LOG(LOG_INFO, "          * LastAccessTime  = 0x%" PRIx64 " (8 bytes)", this->LastAccessTime);
        LOG(LOG_INFO, "          * LastWriteTime   = 0x%" PRIx64 " (8 bytes)", this->LastWriteTime);
        LOG(LOG_INFO, "          * ChangeTime      = 0x%" PRIx64 " (8 bytes)", this->ChangeTime);
        LOG(LOG_INFO, "          * EndOfFile       = 0x%" PRIx64 " (8 bytes)", this->EndOfFile);
        LOG(LOG_INFO, "          * AllocationSize  = 0x%" PRIx64 " (8 bytes)", this->AllocationSize);
        LOG(LOG_INFO, "          * FileAttributes  = 0x%08x (4 bytes): %s", this->FileAttributes, get_FileAttributes_name(this->FileAttributes));
        LOG(LOG_INFO, "          * FileNameLength  = %zu (4 bytes)", this->file_name.size());
        LOG(LOG_INFO, "          * EaSize          = %d (4 bytes)", this->EaSize);
        LOG(LOG_INFO, "          * FileName        = \"%s\" (%zu byte(s))", this->file_name, this->file_name.size());
    }
};  // FileFullDirectoryInformation

// [MS-FSCC] - 2.4.26 FileNamesInformation
// =======================================

// This information class is used in directory enumeration to return detailed
//  information about the contents of a directory.

// This information class returns a list that contains a
//  FILE_NAMES_INFORMATION data element for each file or directory within the
//  target directory. This list MUST reflect the presence of a subdirectory
//  named "." (synonymous with the target directory itself) within the target
//  directory and one named ".." (synonymous with the parent directory of the
//  target directory). For more details, see section 2.1.5.1.

// When multiple FILE_NAMES_INFORMATION data elements are present in the
//  buffer, each MUST be aligned on an 8-byte boundary. Any bytes inserted
//  for alignment SHOULD be set to zero, and the receiver MUST ignore them.
//  No padding is required following the last data element.

// A FILE_NAMES_INFORMATION data element is as follows.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                        NextEntryOffset                        |
// +---------------------------------------------------------------+
// |                           FileIndex                           |
// +---------------------------------------------------------------+
// |                         FileNameLength                        |
// +---------------------------------------------------------------+
// |                      FileName (variable)                      |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// NextEntryOffset (4 bytes): A 32-bit unsigned integer that contains the
//  byte offset from the beginning of this entry, at which the next
//  FILE_NAMES_INFORMATION entry is located, if multiple entries are present
//  in a buffer. This member MUST be zero if no other entries follow this
//  one. An implementation MUST use this value to determine the location of
//  the next entry (if multiple entries are present in a buffer).

// FileIndex (4 bytes): A 32-bit unsigned integer that contains the byte
//  offset of the file within the parent directory. For file systems in which
//  the position of a file within the parent directory is not fixed and can
//  be changed at any time to maintain sort order, this field SHOULD be set
//  to 0, and MUST be ignored.<111>

// FileNameLength (4 bytes): A 32-bit unsigned integer that specifies the
//  length, in bytes, of the file name contained within the FileName member.

// FileName (variable): A sequence of Unicode characters containing the file
//  name. When working with this field, use FileNameLength to determine the
//  length of the file name rather than assuming the presence of a trailing
//  null delimiter.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

class FileNamesInformation {
    uint32_t NextEntryOffset = 0;
    uint32_t FileIndex       = 0;

    std::string file_name;

public:
    enum : unsigned {
        MIN_SIZE = 12
    };

    uint32_t total_size() {
        return this->file_name.length() + MIN_SIZE;
    }

    FileNamesInformation() = default;

    explicit FileNamesInformation(const char * file_name)
      :  file_name([&file_name]() {

        uint8_t FileName_unicode_data[500];
        size_t size_utf16 = ::UTF8toUTF16(reinterpret_cast<const uint8_t *>(file_name),
            FileName_unicode_data, sizeof(FileName_unicode_data));

        const std::string str(reinterpret_cast<char *>(FileName_unicode_data), size_utf16);

        return str;
    }()) {}

    inline void emit(OutStream & stream) const {
        stream.out_uint32_le(this->NextEntryOffset);
        stream.out_uint32_le(this->FileIndex);

//         uint8_t FileName_unicode_data[65536];
//         size_t size_of_FileName_unicode_data = ::UTF8toUTF16(
//             reinterpret_cast<const uint8_t *>(this->file_name.c_str()),
//             FileName_unicode_data, sizeof(FileName_unicode_data));

        stream.out_uint32_le(this->file_name.size());    // FileNameLength(4)

        stream.out_copy_bytes(this->file_name.c_str(), this->file_name.size());
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = MIN_SIZE;    // NextEntryOffset(4) + FileIndex(4)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileNamesInformation (0): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->NextEntryOffset = stream.in_uint32_le();
        this->FileIndex       = stream.in_uint32_le();

        const uint32_t FileNameLength = stream.in_uint32_le();

        {
            const unsigned expected = FileNameLength;   // FileName(variable)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileNamesInformation (1): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_RDPDR_PDU_TRUNCATED);
            }
        }

//         uint8_t const * const FileName_unicode_data = stream.get_current();
//         uint8_t FileName_utf8_string[1024 * 64 / sizeof(uint16_t) * maximum_length_of_utf8_character_in_bytes];
//         const size_t length_of_FileName_utf8_string = ::UTF16toUTF8(
//             FileName_unicode_data, FileNameLength / 2, FileName_utf8_string,
//             sizeof(FileName_utf8_string));
        this->file_name.assign(::char_ptr_cast(stream.get_current()),
            FileNameLength);

        stream.in_skip_bytes(FileNameLength);
    }

    inline size_t size() const {
        size_t size = 12;    // NextEntryOffset(4) + FileIndex(4) + FileNameLength(4)

//         uint8_t unicode_data[65536];
//         size_t size_of_unicode_data = ::UTF8toUTF16(
//             reinterpret_cast<const uint8_t *>(this->file_name.c_str()),
//             unicode_data, sizeof(unicode_data));

        return size + this->file_name.length();
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileNamesInformation: NextEntryOffset=%u FileIndex=%u FileName=\"%s\"",
            this->NextEntryOffset, this->FileIndex, this->file_name.c_str());
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Directory Information:");
        LOG(LOG_INFO, "          * NextEntryOffset = 0x%08x (4 bytes)", this->NextEntryOffset);
        LOG(LOG_INFO, "          * FileIndex       = 0x%08x (4 bytes)", this->FileIndex);
        LOG(LOG_INFO, "          * FileNameLength  = %zu (4 bytes)", this->file_name.size());
        LOG(LOG_INFO, "          * FileName        = \"%s\" (%zu byte(s))", this->file_name, this->file_name.size());
    }
};

// [MS-FSCC] - 2.4.34 FileRenameInformation
// ========================================

// This information class is used to rename a file. The data element provided
//  by the client takes one of two forms, depending on whether it is embedded
//  within SMB or SMB2. The structure definitions are as follows:

// ‚ñ™ FILE_RENAME_INFORMATION_TYPE_1 for the SMB protocol (section 2.4.34.1).

// ‚ñ™ FILE_RENAME_INFORMATION_TYPE_2 for the SMB2 protocol (section 2.4.34.2).

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +------------------------------+-------------------------------------------+
//  | Error code                   | Meaning                                   |
//  +------------------------------+-------------------------------------------+
//  | STATUS_INVALID_PARAMETER     | An invalid parameter was passed for       |
//  | 0xC000000D                   | FileName or FileNameLength, or the target |
//  |                              | file was open, or the RootDirectory field |
//  |                              | value was nonzero for a network           |
//  |                              | operation.                                |
//  +------------------------------+-------------------------------------------+
//  | STATUS_ACCESS_DENIED         | The handle was not opened with delete     |
//  | 0xC0000022                   | access.                                   |
//  +------------------------------+-------------------------------------------+
//  | STATUS_NOT_SAME_DEVICE       | The destination file of a rename request  |
//  | 0xC00000D4                   | is located on a different device than the |
//  |                              | source of the rename request.             |
//  +------------------------------+-------------------------------------------+
//  | STATUS_OBJECT_NAME_INVALID   | The object name is invalid for the target |
//  | 0xC0000033                   | file system.                              |
//  +------------------------------+-------------------------------------------+
//  | STATUS_OBJECT_NAME_COLLISION | The specified name already exists and     |
//  | 0xC0000035                   | ReplaceIfExists is zero.                  |
//  +------------------------------+-------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH  | The specified information record length   |
//  | 0xC0000004                   | does not match the length that is         |
//  |                              | required for the specified information    |
//  |                              | class.                                    |
//  +------------------------------+-------------------------------------------+

//  2.4.34.2 FileRenameInformation for SMB2

//  This information class is used to rename a file from within the SMB2 Protocol [MS-SMB2].

//  A FILE_RENAME_INFORMATION_TYPE_2 data element, defined as follows, is provided by the client.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |ReplaceIfExists|                    Reserved                   |
// +---------------+-----------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         RootDirectory                         |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         FileNameLength                        |
// +---------------------------------------------------------------+
// |                       FileName (variable)                     |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

//  ReplaceIfExists (1 byte):  A Boolean (section 2.1.8) value. Set to TRUE to indicate that if a file with the given name already exists, it SHOULD be replaced with the given file. Set to FALSE to indicate that the rename operation MUST fail if a file with the given name already exists.

//  Reserved (7 bytes): Reserved area for alignment. This field can contain any value and MUST be ignored.

//  RootDirectory (8 bytes): A 64-bit unsigned integer that contains the file handle for the directory to which the new name of the file is relative. For network operations, this value MUST always be zero.

//  FileNameLength (4 bytes):  A 32-bit unsigned integer that specifies the length, in bytes, of the file name contained within the FileName field.

//  FileName (variable):  A sequence of Unicode characters containing the new name of the file. When working with this field, use FileNameLength to determine the length of the file name rather than assuming the presence of a trailing null delimiter. If the RootDirectory field is zero, this member MUST specify a full pathname to be assigned to the file. For network operations, this pathname is relative to the root of the share. If the RootDirectory field is not zero, this field MUST specify a pathname, relative to RootDirectory, for the new name of the file.

struct FileRenameInformation {

    uint8_t ReplaceIfExists = 0;
    uint64_t RootDirectory = 0;
    std::string FileName;

    FileRenameInformation() = default;

    FileRenameInformation( uint8_t ReplaceIfExists
                         , uint64_t RootDirectory
                         , std::string FileName)
      : ReplaceIfExists(ReplaceIfExists)
      , RootDirectory(RootDirectory)
      , FileName(FileName)
      {}

    void emit(OutStream & stream) const {
        stream.out_uint8(this->ReplaceIfExists);
        stream.out_clear_bytes(7);
        stream.out_uint64_le(this->RootDirectory);
        stream.out_uint32_le(this->FileName.size());
        stream.out_copy_bytes(reinterpret_cast<const uint8_t *>(this->FileName.data()), this->FileName.size());
    }

    void receive(InStream & stream) {
        this->ReplaceIfExists = stream.in_uint8();
        stream.in_skip_bytes(7);
        this->RootDirectory = stream.in_uint64_le();
        size_t size = stream.in_uint32_le();
        this->FileName = std::string(reinterpret_cast<const char *>(stream.get_current()), size);
    }

    void log() const {
        LOG(LOG_INFO, "     File Rename Information:");
        LOG(LOG_INFO, "          * ReplaceIfExists = %02x (1 byte)", this->ReplaceIfExists);
        LOG(LOG_INFO, "          * Padding - (7 byte) NOT USED");
        LOG(LOG_INFO, "          * RootDirectory   = %" PRIx64 " (8 bytes)", this->RootDirectory);
        LOG(LOG_INFO, "          * FileNameLength  = %zu (4 bytes)", this->FileName.size());
        LOG(LOG_INFO, "          * VolumeLabel     = \"%s\" (%zu byte(s)", this->FileName, this->FileName.size());
    }
};



// [MS-FSCC] - 2.4.38 FileStandardInformation
// ==========================================

// This information class is used to query file information.

// A FILE_STANDARD_INFORMATION data element, defined as follows, is returned
//  by the server.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                         AllocationSize                        |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                           EndOfFile                           |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                         NumberOfLinks                         |
// +---------------+---------------+-------------------------------+
// | DeletePending |   Directory   |            Reserved           |
// +---------------+---------------+-------------------------------+

// AllocationSize (8 bytes): A 64-bit signed integer that contains the file
//  allocation size, in bytes. The value of this field MUST be an integer
//  multiple of the cluster size.

// EndOfFile (8 bytes): A 64-bit signed integer that contains the absolute
//  end-of-file position as a byte offset from the start of the file.
//  EndOfFile specifies the offset to the byte immediately following the last
//  valid byte in the file. Because this value is zero-based, it actually
//  refers to the first free byte in the file. That is, it is the offset from
//  the beginning of the file at which new bytes appended to the file will be
//  written. The value of this field MUST be greater than or equal to 0.

// NumberOfLinks (4 bytes): A 32-bit unsigned integer that contains the
//  number of non-deleted links to this file.

// DeletePending (1 byte): A Boolean (section 2.1.8) value. Set to TRUE to
//  indicate that a file deletion has been requested; set to FALSE otherwise.

// Directory (1 byte): A Boolean (section 2.1.8) value. Set to TRUE to
//  indicate that the file is a directory; set to FALSE otherwise.

// Reserved (2 bytes): A 16-bit field. This field is reserved. This field can
//  be set to any value, and MUST be ignored.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+-----------------------------------------+
//  | Error code                  | Meaning                                 |
//  +-----------------------------+-----------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length |
//  | 0xC0000004                  | does not match the length that is       |
//  |                             | required for the specified information  |
//  |                             | class.                                  |
//  +-----------------------------+-----------------------------------------+

class FileStandardInformation {
    int64_t  AllocationSize = 0;
    int64_t  EndOfFile      = 0;
    uint32_t NumberOfLinks  = 0;
    uint8_t  DeletePending  = 0;
    uint8_t  Directory      = 0;

public:

    FileStandardInformation() = default;

    FileStandardInformation(int64_t AllocationSize, int64_t EndOfFile,
                            uint32_t NumberOfLinks, uint8_t DeletePending,
                            uint8_t Directory)
    : AllocationSize(AllocationSize)
    , EndOfFile(EndOfFile)
    , NumberOfLinks(NumberOfLinks)
    , DeletePending(DeletePending)
    , Directory(Directory) {}

    inline void emit(OutStream & stream) const {
        stream.out_sint64_le(this->AllocationSize);
        stream.out_sint64_le(this->EndOfFile);
        stream.out_uint32_le(this->NumberOfLinks);
        stream.out_uint8(this->DeletePending);
        stream.out_uint8(this->Directory);
        //stream.out_clear_bytes(2);
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = 22;   // AllocationSize(8) + EndOfFile(8) +
                                            //     NumberOfLinks(4) + DeletePending(1) +
                                            //     Directory(1)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileStandardInformation: expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->AllocationSize = stream.in_uint64_le();
        this->EndOfFile      = stream.in_uint64_le();
        this->NumberOfLinks  = stream.in_uint32_le();
        this->DeletePending  = stream.in_uint8();
        this->Directory      = stream.in_uint8();
    }

    inline static size_t size() {
        return 22;  // AllocationSize(8) + EndOfFile(8) +
                    //     NumberOfLinks(4) + DeletePending(1) +
                    //     Directory(1)
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileStandardInformation: AllocationSize=%" PRId64
                " EndOfFile=%" PRId64 " NumberOfLinks=%" PRIu32 " "
                "DeletePending=%" PRId8 " Directory=%" PRId8,
            this->AllocationSize, this->EndOfFile, this->NumberOfLinks,
            this->DeletePending, this->Directory);
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Standard Information:");
        LOG(LOG_INFO, "          * AllocationSize = 0x%" PRIx64 " (8 bytes)", this->AllocationSize);
        LOG(LOG_INFO, "          * EndOfFile      = 0x%" PRIx64 " (8 bytes)", this->EndOfFile);
        LOG(LOG_INFO, "          * NumberOfLinks  = 0x%08x (4 bytes)", this->NumberOfLinks);
        LOG(LOG_INFO, "          * DeletePending  = 0x%02x (1 byte)", this->DeletePending);
        LOG(LOG_INFO, "          * Directory      = 0x%02x (1 byte)", this->Directory);
        LOG(LOG_INFO, "          * Reserved - (2 bytes) Not Used");
    }
};  // FileStandardInformation

// [MS-FSCC] - 2.5.1 FileFsAttributeInformation
// ============================================

// This information class is used to query attribute information for a file
//  system.

// A FILE_FS_ATTRIBUTE_INFORMATION data element, defined as follows, is
//  returned by the server.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                      FileSystemAttributes                     |
// +---------------------------------------------------------------+
// |                   MaximumComponentNameLength                  |
// +---------------------------------------------------------------+
// |                      FileSystemNameLength                     |
// +---------------------------------------------------------------+
// |                   FileSystemName (variable)                   |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// FileSystemAttributes (4 bytes): A 32-bit unsigned integer that contains a
//  bitmask of flags that specify attributes of the specified file system as
//  a combination of the following flags. The value of this field MUST be a
//  bitwise OR of zero or more of the following with the exception that
//  FILE_FILE_COMPRESSION and FILE_VOLUME_IS_COMPRESSED cannot both be set.
//  Any flag values not explicitly mentioned here can be set to any value,
//  and MUST be ignored.

//  +-----------------------------------+--------------------------------------+
//  | Value                             | Meaning                              |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_USN_JOURNAL         | The file system implements a USN     |
//  | 0x02000000                        | change journal.<126>                 |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_OPEN_BY_FILE_ID     | The file system supports opening a   |
//  | 0x01000000                        | file by FileID or ObjectID.<127>     |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_EXTENDED_ATTRIBUTES | The file system persistently stores  |
//  | 0x00800000                        | Extended Attribute information per   |
//  |                                   | file.<128>                           |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_HARD_LINKS          | The file system supports hard        |
//  | 0x00400000                        | linking files.<129>                  |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_TRANSACTIONS        | The volume supports                  |
//  | 0x00200000                        | transactions.<130>                   |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SEQUENTIAL_WRITE_ONCE        | The underlying volume is write once. |
//  | 0x00100000                        |                                      |
//  +-----------------------------------+--------------------------------------+
//  | FILE_READ_ONLY_VOLUME             | If set, the volume has been mounted  |
//  | 0x00080000                        | in read-only mode.<131>              |
//  +-----------------------------------+--------------------------------------+
//  | FILE_NAMED_STREAMS                | The file system supports named       |
//  | 0x00040000                        | streams.                             |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_ENCRYPTION          | The file system supports the         |
//  | 0x00020000                        | Encrypted File System (EFS).<132>    |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_OBJECT_IDS          | The file system supports object      |
//  | 0x00010000                        | identifiers.                         |
//  +-----------------------------------+--------------------------------------+
//  | FILE_VOLUME_IS_COMPRESSED         | The specified volume is a compressed |
//  | 0x00008000                        | volume. This flag is incompatible    |
//  |                                   | with the FILE_FILE_COMPRESSION flag. |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_REMOTE_STORAGE      | The file system supports remote      |
//  | 0x00000100                        | storage.<133>                        |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_REPARSE_POINTS      | The file system supports reparse     |
//  | 0x00000080                        | points.                              |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORTS_SPARSE_FILES        | The file system supports sparse      |
//  | 0x00000040                        | files.                               |
//  +-----------------------------------+--------------------------------------+
//  | FILE_VOLUME_QUOTAS                | The file system supports per-user    |
//  | 0x00000020                        | quotas.                              |
//  +-----------------------------------+--------------------------------------+
//  | FILE_FILE_COMPRESSION             | The file volume supports file-based  |
//  | 0x00000010                        | compression. This flag is            |
//  |                                   | incompatible with the                |
//  |                                   | FILE_VOLUME_IS_COMPRESSED flag.      |
//  +-----------------------------------+--------------------------------------+
//  | FILE_PERSISTENT_ACLS              | The file system preserves and        |
//  | 0x00000008                        | enforces access control lists        |
//  |                                   | (ACLs).                              |
//  +-----------------------------------+--------------------------------------+
//  | FILE_UNICODE_ON_DISK              | The file system supports Unicode in  |
//  | 0x00000004                        | file and directory names. This flag  |
//  |                                   | applies only to file and directory   |
//  |                                   | names; the file system neither       |
//  |                                   | restricts nor interprets the bytes   |
//  |                                   | of data within a file.               |
//  +-----------------------------------+--------------------------------------+
//  | FILE_CASE_PRESERVED_NAMES         | The file system preserves the case   |
//  | 0x00000002                        | of file names when it places a name  |
//  |                                   | on disk.                             |
//  +-----------------------------------+--------------------------------------+
//  | FILE_CASE_SENSITIVE_SEARCH        | The file system supports             |
//  | 0x00000001                        | case-sensitive file names when       |
//  |                                   | looking up (searching for) file      |
//  |                                   | names in a directory.                |
//  +-----------------------------------+--------------------------------------+
//  | FILE_SUPPORT_INTEGRITY_STREAMS    | The file system supports integrity   |
//  | 0x04000000                        | streams.<134>                        |
//  +-----------------------------------+--------------------------------------+

enum {
      FILE_SUPPORTS_USN_JOURNAL         = 0x02000000
    , FILE_SUPPORTS_OPEN_BY_FILE_ID     = 0x01000000
    , FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x00800000
    , FILE_SUPPORTS_HARD_LINKS          = 0x00400000
    , FILE_SUPPORTS_TRANSACTIONS        = 0x00200000
    , FILE_SEQUENTIAL_WRITE_ONCE        = 0x00100000
    , FILE_READ_ONLY_VOLUME             = 0x00080000
    , FILE_NAMED_STREAMS                = 0x00040000
    , FILE_SUPPORTS_ENCRYPTION          = 0x00020000
    , FILE_SUPPORTS_OBJECT_IDS          = 0x00010000
    , FILE_VOLUME_IS_COMPRESSED         = 0x00008000
    , FILE_SUPPORTS_REMOTE_STORAGE      = 0x00000100
    , FILE_SUPPORTS_REPARSE_POINTS      = 0x00000080
    , FILE_SUPPORTS_SPARSE_FILES        = 0x00000040
    , FILE_VOLUME_QUOTAS                = 0x00000020
    , FILE_FILE_COMPRESSION             = 0x00000010
    , FILE_PERSISTENT_ACLS              = 0x00000008
    , FILE_UNICODE_ON_DISK              = 0x00000004
    , FILE_CASE_PRESERVED_NAMES         = 0x00000002
    , FILE_CASE_SENSITIVE_SEARCH        = 0x00000001
    , FILE_SUPPORT_INTEGRITY_STREAMS    = 0x04000000
};



// MaximumComponentNameLength (4 bytes): A 32-bit signed integer that
//  contains the maximum file name component length, in bytes, supported by
//  the specified file system. The value of this field MUST be greater than
//  zero and MUST be no more than 510.<135>

// FileSystemNameLength (4 bytes): A 32-bit unsigned integer that contains
//  the length, in bytes, of the file system name in the FileSystemName
//  field. The value of this field MUST be greater than 0.

// FileSystemName (variable): A variable-length Unicode field containing the
//  name of the file system. This field is not null-terminated and MUST be
//  handled as a sequence of FileSystemNameLength bytes. This field is
//  intended to be informative only. A client SHOULD NOT infer file system
//  type specific behavior from this field.<136>

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_BUFFER_OVERFLOW      | The output buffer was filled before all of |
//  | 0x80000005                  | the file system information could be       |
//  |                             | returned; only a portion of the            |
//  |                             | FileSystemName field is returned.          |
//  +-----------------------------+--------------------------------------------+

class FileFsAttributeInformation {
    uint32_t FileSystemAttributes_      = 0;
    uint32_t MaximumComponentNameLength = 0;

    std::string file_system_name;

public:
    FileFsAttributeInformation() = default;

    FileFsAttributeInformation(uint32_t FileSystemAttributes,
                               uint32_t MaximumComponentNameLength,
                               const char * file_system_name)
    : FileSystemAttributes_(FileSystemAttributes)
    , MaximumComponentNameLength(MaximumComponentNameLength)
    , file_system_name(file_system_name) {}

    inline void emit(OutStream & stream) const {
        stream.out_uint32_le(this->FileSystemAttributes_);
        stream.out_sint32_le(this->MaximumComponentNameLength);

        uint8_t unicode_data[65536];
        const size_t size_of_unicode_data = ::UTF8toUTF16(
            reinterpret_cast<const uint8_t *>(this->file_system_name.c_str()),
            unicode_data, sizeof(unicode_data));

        stream.out_uint32_le(size_of_unicode_data); // FileSystemNameLength(4)

        stream.out_copy_bytes(unicode_data, size_of_unicode_data);
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = 12;   // FileSystemAttributes(4) + MaximumComponentNameLength(4) +
                                            //     FileSystemNameLength(4)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFsAttributeInformation (0): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->FileSystemAttributes_      = stream.in_uint32_le();
        this->MaximumComponentNameLength = stream.in_sint32_le();

        const uint32_t FileSystemNameLength = stream.in_uint32_le();

        {
            const unsigned expected = FileSystemNameLength; // FileSystemName(variable)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFsAttributeInformation (1): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_RDPDR_PDU_TRUNCATED);
            }
        }

        uint8_t const * const FileSystemName = stream.get_current();
        uint8_t FileSystemName_utf8_string[1024 * 64 / sizeof(uint16_t) * maximum_length_of_utf8_character_in_bytes];

        const size_t length_of_FileSystemName_utf8_string = ::UTF16toUTF8(
            FileSystemName, FileSystemNameLength / 2, FileSystemName_utf8_string,
            sizeof(FileSystemName_utf8_string));
        this->file_system_name.assign(::char_ptr_cast(FileSystemName_utf8_string),
            length_of_FileSystemName_utf8_string);

        stream.in_skip_bytes(FileSystemNameLength);
    }

    inline size_t size() const {
        const size_t size = 12; // FileSystemAttributes(4) + MaximumComponentNameLength(4) +
                                //     FileSystemNameLength(4)

        uint8_t unicode_data[65536];
        const size_t size_of_unicode_data = ::UTF8toUTF16(
            reinterpret_cast<const uint8_t *>(this->file_system_name.c_str()),
            unicode_data, sizeof(unicode_data));

        return size + size_of_unicode_data;
    }

    uint32_t FileSystemAttributes() const { return this->FileSystemAttributes_; }

    inline void set_FileSystemAttributes(uint32_t FileSystemAttributes) {
        this->FileSystemAttributes_ = FileSystemAttributes;
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileFsAttributeInformation: FileSystemAttributes=0x%X "
                " MaximumComponentNameLength=%u FileSystemName=\"%s\"",
            this->FileSystemAttributes_, this->MaximumComponentNameLength,
            this->file_system_name.c_str());
        return ((length < size) ? length : size - 1);
    }


    static inline
std::string get_FileSystemAttributes_name(uint32_t FileSystemAttribute) {

    std::string str;
    (FileSystemAttribute & FILE_SUPPORTS_USN_JOURNAL) ? str+="FILE_SUPPORTS_USN_JOURNAL " :str;
    (FileSystemAttribute & FILE_SUPPORTS_OPEN_BY_FILE_ID) ? str+="FILE_SUPPORTS_OPEN_BY_FILE_ID " :str;
    (FileSystemAttribute & FILE_SUPPORTS_EXTENDED_ATTRIBUTES) ? str+="FILE_SUPPORTS_EXTENDED_ATTRIBUTES " :str;

    (FileSystemAttribute & FILE_SUPPORTS_HARD_LINKS) ? str+="FILE_SUPPORTS_HARD_LINKS " : str;
    (FileSystemAttribute & FILE_SUPPORTS_TRANSACTIONS) ? str+="FILE_SUPPORTS_TRANSACTIONS " : str;
    (FileSystemAttribute & FILE_SEQUENTIAL_WRITE_ONCE) ? str+="FILE_SEQUENTIAL_WRITE_ONCE " : str;

    (FileSystemAttribute & FILE_READ_ONLY_VOLUME) ? str+="FILE_READ_ONLY_VOLUME " : str;
    (FileSystemAttribute & FILE_NAMED_STREAMS) ? str+="FILE_NAMED_STREAMS " : str;
    (FileSystemAttribute & FILE_SUPPORTS_ENCRYPTION) ? str+="FILE_SUPPORTS_ENCRYPTION " : str;

    (FileSystemAttribute & FILE_SUPPORTS_OBJECT_IDS) ? str+="FILE_SUPPORTS_OBJECT_IDS ":str;
    (FileSystemAttribute & FILE_VOLUME_IS_COMPRESSED) ? str+="FILE_VOLUME_IS_COMPRESSED " : str;
    (FileSystemAttribute & FILE_SUPPORTS_REMOTE_STORAGE) ? str+="FILE_SUPPORTS_REMOTE_STORAGE " : str;

    (FileSystemAttribute & FILE_SUPPORTS_REPARSE_POINTS) ? str+="FILE_SUPPORTS_REPARSE_POINTS " : str;
    (FileSystemAttribute & FILE_SUPPORTS_SPARSE_FILES) ? str+="FILE_SUPPORTS_SPARSE_FILES " : str;
    (FileSystemAttribute & FILE_VOLUME_QUOTAS) ? str+="FILE_VOLUME_QUOTAS " : str;


    (FileSystemAttribute & FILE_FILE_COMPRESSION) ? str+="FILE_FILE_COMPRESSION " : str;
    (FileSystemAttribute & FILE_PERSISTENT_ACLS) ? str+="FILE_PERSISTENT_ACLS " : str;
    (FileSystemAttribute & FILE_UNICODE_ON_DISK) ? str+="FILE_UNICODE_ON_DISK " : str;

    (FileSystemAttribute & FILE_CASE_PRESERVED_NAMES) ? str+="FILE_CASE_PRESERVED_NAMES " : str;
    (FileSystemAttribute & FILE_CASE_SENSITIVE_SEARCH) ? str+="FILE_CASE_SENSITIVE_SEARCH " : str;
    (FileSystemAttribute & FILE_SUPPORT_INTEGRITY_STREAMS) ? str+="FILE_SUPPORT_INTEGRITY_STREAMS " : str;

    return str;
}



public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Fs Attribute Information:");
        LOG(LOG_INFO, "          * FileSystemAttributes       = 0x%08x (4 bytes): %s", this->FileSystemAttributes_, get_FileSystemAttributes_name(this->FileSystemAttributes_));
        LOG(LOG_INFO, "          * MaximumComponentNameLength = %d (4 bytes)", int(this->MaximumComponentNameLength));
        LOG(LOG_INFO, "          * FileSystemNameLength       = %zu (4 bytes)", this->file_system_name.size());
        LOG(LOG_INFO, "          * FileSystemName             = \"%s\" (%zu byte(s))", this->file_system_name, this->file_system_name.size());
    }
};  // FileFsAttributeInformation

// [MS-FSCC] - 2.5.4 FileFsFullSizeInformation
// ===========================================

// This information class is used to query sector size information for a file
//  system volume.

// A FILE_FS_FULL_SIZE_INFORMATION data element, defined as follows, is
//  returned by the server.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                      TotalAllocationUnits                     |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                 CallerAvailableAllocationUnits                |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                 ActualAvailableAllocationUnits                |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                    SectorsPerAllocationUnit                   |
// +---------------------------------------------------------------+
// |                         BytesPerSector                        |
// +---------------------------------------------------------------+

// TotalAllocationUnits (8 bytes): A 64-bit signed integer that contains the
//  total number of allocation units on the volume that are available to the
//  user associated with the calling thread. The value of this field MUST be
//  greater than or equal to 0.<142>

// CallerAvailableAllocationUnits (8 bytes): A 64-bit signed integer that
//  contains the total number of free allocation units on the volume that are
//  available to the user associated with the calling thread. The value of
//  this field MUST be greater than or equal to 0.<143>

// ActualAvailableAllocationUnits (8 bytes): A 64-bit signed integer that
//  contains the total number of free allocation units on the volume. The
//  value of this field MUST be greater than or equal to 0.

// SectorsPerAllocationUnit (4 bytes): A 32-bit unsigned integer that
//  contains the number of sectors in each allocation unit.

// BytesPerSector (4 bytes): A 32-bit unsigned integer that contains the
//  number of bytes in each sector.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

class FileFsFullSizeInformation {
    int64_t  TotalAllocationUnits           = 0;
    int64_t  CallerAvailableAllocationUnits = 0;
    int64_t  ActualAvailableAllocationUnits = 0;
    uint32_t SectorsPerAllocationUnit       = 0;
    uint32_t BytesPerSector                 = 0;

public:
    FileFsFullSizeInformation() = default;

    FileFsFullSizeInformation(int64_t TotalAllocationUnits,
                              int64_t CallerAvailableAllocationUnits,
                              int64_t ActualAvailableAllocationUnits,
                              uint32_t SectorsPerAllocationUnit,
                              uint32_t BytesPerSector)
    : TotalAllocationUnits(TotalAllocationUnits)
    , CallerAvailableAllocationUnits(CallerAvailableAllocationUnits)
    , ActualAvailableAllocationUnits(ActualAvailableAllocationUnits)
    , SectorsPerAllocationUnit(SectorsPerAllocationUnit)
    , BytesPerSector(BytesPerSector) {}

    inline void emit(OutStream & stream) const {
        stream.out_sint64_le(this->TotalAllocationUnits);
        stream.out_sint64_le(this->CallerAvailableAllocationUnits);
        stream.out_sint64_le(this->ActualAvailableAllocationUnits);
        stream.out_uint32_le(this->SectorsPerAllocationUnit);
        stream.out_uint32_le(this->BytesPerSector);
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = 32;   // TotalAllocationUnits(8) +
                                            //     CallerAvailableAllocationUnits(8)
                                            //     ActualAvailableAllocationUnits(8) +
                                            //     SectorsPerAllocationUnit(4) +
                                            //     BytesPerSector(4)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFsFullSizeInformation: expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->TotalAllocationUnits           = stream.in_sint64_le();
        this->CallerAvailableAllocationUnits = stream.in_sint64_le();
        this->ActualAvailableAllocationUnits = stream.in_sint64_le();
        this->SectorsPerAllocationUnit       = stream.in_uint32_le();
        this->BytesPerSector                 = stream.in_uint32_le();
    }

    inline size_t size() const {
        return 32;  // TotalAllocationUnits(8) + CallerAvailableAllocationUnits(8) +
                    //     ActualAvailableAllocationUnits(8) + SectorsPerAllocationUnit(4) +
                    //     BytesPerSector(4)
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileFsFullSizeInformation: TotalAllocationUnits=%" PRId64
                " CallerAvailableAllocationUnits=%" PRId64
                " ActualAvailableAllocationUnits=%" PRId64
                " SectorsPerAllocationUnit=%u BytesPerSector=%u",
            this->TotalAllocationUnits, this->CallerAvailableAllocationUnits,
            this->ActualAvailableAllocationUnits, this->SectorsPerAllocationUnit,
            this->BytesPerSector);
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Fs Full Size Information:");
        LOG(LOG_INFO, "          * TotalAllocationUnits           = 0x%" PRIx64 " (8 bytes)", this->TotalAllocationUnits);
        LOG(LOG_INFO, "          * CallerAvailableAllocationUnits = 0x%" PRIx64 " (8 bytes)", this->CallerAvailableAllocationUnits);
        LOG(LOG_INFO, "          * ActualAvailableAllocationUnits = 0x%" PRIx64 " (8 bytes)", this->ActualAvailableAllocationUnits);
        LOG(LOG_INFO, "          * SectorsPerAllocationUnit       = %u (4 bytes)", this->SectorsPerAllocationUnit);
        LOG(LOG_INFO, "          * BytesPerSector                 = %u (4 bytes)", this->BytesPerSector);
    }
};

// [MS-FSCC] - 2.5.8 FileFsSizeInformation
// =======================================

// This information class is used to query sector size information for a file
//  system volume.

// A FILE_FS_SIZE_INFORMATION data element, defined as follows, is returned
//  by the server.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                      TotalAllocationUnits                     |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                    AvailableAllocationUnits                   |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                    SectorsPerAllocationUnit                   |
// +---------------------------------------------------------------+
// |                         BytesPerSector                        |
// +---------------------------------------------------------------+

// TotalAllocationUnits (8 bytes): A 64-bit signed integer that contains the
//  total number of allocation units on the volume that are available to the
//  user associated with the calling thread. This value MUST be greater than
//  or equal to 0.<152>

// AvailableAllocationUnits (8 bytes): A 64-bit signed integer that contains
//  the total number of free allocation units on the volume that are
//  available to the user associated with the calling thread. This value MUST
//  be greater than or equal to 0.<153>

// SectorsPerAllocationUnit (4 bytes): A 32-bit unsigned integer that
//  contains the number of sectors in each allocation unit.

// BytesPerSector (4 bytes): A 32-bit unsigned integer that contains the
//  number of bytes in each sector.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

class FileFsSizeInformation {
    int64_t  TotalAllocationUnits     = 0;
    int64_t  AvailableAllocationUnits = 0;
    uint32_t SectorsPerAllocationUnit = 0;
    uint32_t BytesPerSector           = 0;

public:
    FileFsSizeInformation() = default;

    FileFsSizeInformation(int64_t TotalAllocationUnits,
                          int64_t AvailableAllocationUnits,
                          uint32_t SectorsPerAllocationUnit,
                          uint32_t BytesPerSector)
    : TotalAllocationUnits(TotalAllocationUnits)
    , AvailableAllocationUnits(AvailableAllocationUnits)
    , SectorsPerAllocationUnit(SectorsPerAllocationUnit)
    , BytesPerSector(BytesPerSector) {}

    inline void emit(OutStream & stream) const {
        stream.out_sint64_le(this->TotalAllocationUnits);
        stream.out_sint64_le(this->AvailableAllocationUnits);
        stream.out_uint32_le(this->SectorsPerAllocationUnit);
        stream.out_uint32_le(this->BytesPerSector);
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = 24;   // TotalAllocationUnits(8) +
                                            //     AvailableAllocationUnits(8) +
                                            //     SectorsPerAllocationUnit(4) +
                                            //     BytesPerSector(4)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFsSizeInformation: expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->TotalAllocationUnits     = stream.in_sint64_le();
        this->AvailableAllocationUnits = stream.in_sint64_le();
        this->SectorsPerAllocationUnit = stream.in_uint32_le();
        this->BytesPerSector           = stream.in_uint32_le();
    }

    inline size_t size() const {
        return 24;  // TotalAllocationUnits(8) + AvailableAllocationUnits(8) +
                    //     SectorsPerAllocationUnit(4) + BytesPerSector(4)
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileFsSizeInformation: TotalAllocationUnits=%" PRId64
                " AvailableAllocationUnits=%" PRId64
                " SectorsPerAllocationUnit=%u BytesPerSector=%u",
            this->TotalAllocationUnits, this->AvailableAllocationUnits,
            this->SectorsPerAllocationUnit, this->BytesPerSector);
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Fs Size Information:");
        LOG(LOG_INFO, "          * TotalAllocationUnits     = 0x%" PRIx64 " (8 bytes)", this->TotalAllocationUnits);
        LOG(LOG_INFO, "          * AvailableAllocationUnits = 0x%" PRIx64 " (8 bytes)", this->AvailableAllocationUnits);
        LOG(LOG_INFO, "          * SectorsPerAllocationUnit = 0x%08x (4 byte)", this->SectorsPerAllocationUnit);
        LOG(LOG_INFO, "          * BytesPerSector           = %u (4 bytes)", this->BytesPerSector);
    }
};

// [MS-FSCC] - 2.5.9 FileFsVolumeInformation
// =========================================

// This information class is used to query information on a volume on which a
//  file system is mounted. A FILE_FS_VOLUME_INFORMATION data element,
//  defined as follows, is returned by the server.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                       VolumeCreationTime                      |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+
// |                       VolumeSerialNumber                      |
// +---------------------------------------------------------------+
// |                       VolumeLabelLength                       |
// +---------------+---------------+-------------------------------+
// |SupportsObjects|    Reserved   |     VolumeLabel (variable)    |
// +---------------+---------------+-------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// VolumeCreationTime (8 bytes): The time when the volume was created; see
//  section 2.1.1. The value of this field MUST be greater than or equal to
//  0.

// VolumeSerialNumber (4 bytes): A 32-bit unsigned integer that contains the
//  serial number of the volume. The serial number is an opaque value
//  generated by the file system at format time, and is not necessarily
//  related to any hardware serial number for the device on which the file
//  system is located. No specific format or content of this field is
//  required for protocol interoperation. This value is not required to be
//  unique.

// VolumeLabelLength (4 bytes): A 32-bit unsigned integer that contains the
//  length, in bytes, including the trailing null, if present, of the name of
//  the volume.<154>

// SupportsObjects (1 byte): A Boolean (section 2.1.8) value. Set to TRUE if
//  the file system supports object-oriented file system objects; set to
//  FALSE otherwise.<155>

// Reserved (1 byte): An 8-bit field. This field is reserved. This field MUST
//  be set to zero and MUST be ignored.

// VolumeLabel (variable): A variable-length Unicode field containing the
//  name of the volume. The content of this field can be a null-terminated
//  string or can be a string padded with the space character to be
//  VolumeLabelLength bytes long.

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_BUFFER_OVERFLOW      | The output buffer was filled before all of |
//  | 0x80000005                  | the volume information could be returned;  |
//  |                             | only a portion of the VolumeLabel field is |
//  |                             | returned.                                  |
//  +-----------------------------+--------------------------------------------+

class FileFsVolumeInformation {
    uint64_t VolumeCreationTime = 0;
    uint32_t VolumeSerialNumber = 0;
    uint8_t  SupportsObjects    = 0;

    std::string volume_label;

public:
    FileFsVolumeInformation() = default;

    FileFsVolumeInformation(uint64_t VolumeCreationTime, uint32_t VolumeSerialNumber,
                         uint8_t SupportsObjects, const char * volume_label)
    : VolumeCreationTime(VolumeCreationTime)
    , VolumeSerialNumber(VolumeSerialNumber)
    , SupportsObjects(SupportsObjects)
    , volume_label(volume_label) {}

    inline void emit(OutStream & stream) const {
        stream.out_uint64_le(this->VolumeCreationTime);
        stream.out_uint32_le(this->VolumeSerialNumber);

        uint8_t VolumeLabel_unicode_data[65536];
        size_t size_of_VolumeLabel_unicode_data = ::UTF8toUTF16(
            reinterpret_cast<const uint8_t *>(this->volume_label.c_str()),
            VolumeLabel_unicode_data, sizeof(VolumeLabel_unicode_data));

        stream.out_uint32_le(size_of_VolumeLabel_unicode_data); // VolumeLabelLength(4)

        stream.out_uint8(this->SupportsObjects);

        // Reserved(1), MUST NOT be transmitted.

        stream.out_copy_bytes(VolumeLabel_unicode_data,
            size_of_VolumeLabel_unicode_data);
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = 17;   // VolumeCreationTime(8) + VolumeSerialNumber(4) +
                                            //     VolumeLabelLength(4) + SupportsObjects(1)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFsVolumeInformation (0): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->VolumeCreationTime = stream.in_uint64_le();
        this->VolumeSerialNumber = stream.in_uint32_le();

        const uint32_t VolumeLabelLength = stream.in_uint32_le();

        this->SupportsObjects  = stream.in_uint8();

        // Reserved(1), MUST NOT be transmitted.

        {
            const unsigned expected = VolumeLabelLength;    // VolumeLabel(variable)

            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFsVolumeInformation (1): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_RDPDR_PDU_TRUNCATED);
            }
        }

        uint8_t const * const VolumeLabel_unicode_data = stream.get_current();
        uint8_t VolumeLabel_utf8_string[1024 * 64 / sizeof(uint16_t) * maximum_length_of_utf8_character_in_bytes + 1];

        const size_t length_of_VolumeLabel_utf8_string = ::UTF16toUTF8(
            VolumeLabel_unicode_data, VolumeLabelLength / 2,
            VolumeLabel_utf8_string, sizeof(VolumeLabel_utf8_string) - 1);

        stream.in_skip_bytes(VolumeLabelLength);

        VolumeLabel_utf8_string[length_of_VolumeLabel_utf8_string] = '\0';
        for (uint8_t * c =
                 VolumeLabel_utf8_string + length_of_VolumeLabel_utf8_string - 1;
             (c >= VolumeLabel_utf8_string) && ((*c) == ' '); c--) {
            *c = '\0';
        }

        this->volume_label = ::char_ptr_cast(VolumeLabel_utf8_string);
    }

    inline size_t size() const {
        const size_t size = 17; // VolumeCreationTime(8) + VolumeSerialNumber(4) +
                                //     VolumeLabelLength(4) + SupportsObjects(1)

        // Reserved(1), MUST NOT be transmitted.

        uint8_t unicode_data[65536];
        size_t size_of_unicode_data = ::UTF8toUTF16(
            reinterpret_cast<const uint8_t *>(this->volume_label.c_str()),
            unicode_data, sizeof(unicode_data));

        return size + size_of_unicode_data;
    }

private:
    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileFsVolumeInformation: VolumeCreationTime=%" PRIu64
                " VolumeSerialNumber=0x%X SupportsObjects=%" PRId8 " VolumeLabel=\"%s\"",
            this->VolumeCreationTime, this->VolumeSerialNumber,
            this->SupportsObjects, this->volume_label.c_str());
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Fs Volume Information:");
        LOG(LOG_INFO, "          * VolumeCreationTime = 0x%" PRIx64 " (8 bytes)", this->VolumeCreationTime);
        LOG(LOG_INFO, "          * VolumeSerialNumber = 0x%08x (4 bytes)", this->VolumeSerialNumber);
        LOG(LOG_INFO, "          * VolumeLabelLength  = %zu (4 bytes)", this->volume_label.size());
        LOG(LOG_INFO, "          * SupportsObjects    = 0x%02x (1 byte)", this->SupportsObjects);
        LOG(LOG_INFO, "          * Padding - (1 byte) NOT USED");
        LOG(LOG_INFO, "          * VolumeLabel        = \"%s\" (%zu byte(s))", this->volume_label, this->volume_label.size());
    }
};  // FileFsVolumeInformation

// [MS-FSCC] - 2.5.10 FileFsDeviceInformation
// ==========================================

// This information class is used to query device information associated with
//  a file system volume.

// A FILE_FS_DEVICE_INFORMATION data element, defined as follows, is returned
//  by the server.

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                           DeviceType                          |
// +---------------------------------------------------------------+
// |                        Characteristics                        |
// +---------------------------------------------------------------+

// DeviceType (4 bytes): This identifies the type of given volume. It MUST be
//  one of the following.

//  +--------------------+-----------------------------+
//  | Value              | Meaning                     |
//  +--------------------+-----------------------------+
//  | FILE_DEVICE_CD_ROM | Volume resides on a CD ROM. |
//  | 0x00000002         |                             |
//  +--------------------+-----------------------------+
//  | FILE_DEVICE_DISK   | Volume resides on a disk.   |
//  | 0x00000007         |                             |
//  +--------------------+-----------------------------+

enum {
      FILE_DEVICE_CD_ROM = 0x00000002
    , FILE_DEVICE_DISK   = 0x00000007
};

// Characteristics (4 bytes): A bit field which identifies various
//  characteristics about a given volume. The following are valid bit values.

//  +------------------------------------------+-------------------------------+
//  | Value                                    | Meaning                       |
//  +------------------------------------------+-------------------------------+
//  | FILE_REMOVABLE_MEDIA                     | Indicates that the storage    |
//  | 0x00000001                               | device supports removable     |
//  |                                          | media. Notice that this       |
//  |                                          | characteristic indicates      |
//  |                                          | removable media, not a        |
//  |                                          | removable device. For         |
//  |                                          | example, drivers for JAZ      |
//  |                                          | drive devices specify this    |
//  |                                          | characteristic, but drivers   |
//  |                                          | for PCMCIA flash disks do     |
//  |                                          | not.                          |
//  +------------------------------------------+-------------------------------+
//  | FILE_READ_ONLY_DEVICE                    | Indicates that the device     |
//  | 0x00000002                               | cannot be written to.         |
//  +------------------------------------------+-------------------------------+
//  | FILE_FLOPPY_DISKETTE                     | Indicates that the device is  |
//  | 0x00000004                               | a floppy disk device.         |
//  +------------------------------------------+-------------------------------+
//  | FILE_WRITE_ONCE_MEDIA                    | Indicates that the device     |
//  | 0x00000008                               | supports write-once media.    |
//  +------------------------------------------+-------------------------------+
//  | FILE_REMOTE_DEVICE                       | Indicates that the volume is  |
//  | 0x00000010                               | for a remote file system like |
//  |                                          | SMB or CIFS.                  |
//  +------------------------------------------+-------------------------------+
//  | FILE_DEVICE_IS_MOUNTED                   | Indicates that a file system  |
//  | 0x00000020                               | is mounted on the device.     |
//  +------------------------------------------+-------------------------------+
//  | FILE_VIRTUAL_VOLUME                      | Indicates that the volume     |
//  | 0x00000040                               | does not directly reside on   |
//  |                                          | storage media, but resides on |
//  |                                          | some other type of media      |
//  |                                          | (memory for example).         |
//  +------------------------------------------+-------------------------------+
//  | FILE_DEVICE_SECURE_OPEN                  | By default, volumes do not    |
//  | 0x00000100                               | check the ACL associated with |
//  |                                          | the volume, but instead use   |
//  |                                          | the ACLs associated with      |
//  |                                          | individual files on the       |
//  |                                          | volume. When this flag is set |
//  |                                          | the volume ACL is also        |
//  |                                          | checked.                      |
//  +------------------------------------------+-------------------------------+
//  | FILE_CHARACTERISTIC_TS_DEVICE            | Indicates that the device     |
//  | 0x00001000                               | object is part of a Terminal  |
//  |                                          | Services device stack. See    |
//  |                                          | [MS-RDPBCGR] for more         |
//  |                                          | information.                  |
//  +------------------------------------------+-------------------------------+
//  | FILE_CHARACTERISTIC_WEBDAV_DEVICE        | Indicates that a web-based    |
//  | 0x00002000                               | Distributed Authoring and     |
//  |                                          | Versioning (WebDAV) file      |
//  |                                          | system is mounted on the      |
//  |                                          | device. See [MS- WDVME] for   |
//  |                                          | more information.             |
//  +------------------------------------------+-------------------------------+
//  | FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL | The IO Manager performs a     |
//  | 0x00020000                               | full security check for       |
//  |                                          | traverse access if the client |
//  |                                          | is an appcontainer.<156>      |
//  +------------------------------------------+-------------------------------+

enum {
      FILE_REMOVABLE_MEDIA                      = 0x00000001
    , FILE_READ_ONLY_DEVICE                     = 0x00000002
    , FILE_FLOPPY_DISKETTE                      = 0x00000004
    , FILE_WRITE_ONCE_MEDIA                     = 0x00000008
    , FILE_REMOTE_DEVICE                        = 0x00000010
    , FILE_DEVICE_IS_MOUNTED                    = 0x00000020
    , FILE_VIRTUAL_VOLUME                       = 0x00000040
    , FILE_DEVICE_SECURE_OPEN                   = 0x00000100
    , FILE_CHARACTERISTIC_TS_DEVICE             = 0x00001000
    , FILE_CHARACTERISTIC_WEBDAV_DEVICE         = 0x00002000
    , FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL  = 0x00020000
};

// This operation returns a status code, as specified in [MS-ERREF] section
//  2.3. The status code returned directly by the function that processes
//  this file information class MUST be STATUS_SUCCESS or one of the
//  following.

//  +-----------------------------+--------------------------------------------+
//  | Error code                  | Meaning                                    |
//  +-----------------------------+--------------------------------------------+
//  | STATUS_INFO_LENGTH_MISMATCH | The specified information record length    |
//  | 0xC0000004                  | does not match the length that is required |
//  |                             | for the specified information class.       |
//  +-----------------------------+--------------------------------------------+

class FileFsDeviceInformation {
    uint32_t DeviceType      = 0;
    uint32_t Characteristics = 0;

public:
    FileFsDeviceInformation() = default;

    FileFsDeviceInformation(uint32_t DeviceType, uint32_t Characteristics)
    : DeviceType(DeviceType)
    , Characteristics(Characteristics) {}

    inline void emit(OutStream & stream) const {
        stream.out_uint32_le(this->DeviceType);
        stream.out_uint32_le(this->Characteristics);
    }

    inline void receive(InStream & stream) {
        {
            const unsigned expected = 8;    // DeviceType(4) + Characteristics(4)
            if (!stream.in_check_rem(expected)) {
                LOG(LOG_ERR,
                    "Truncated FileFsDeviceInformation (0): expected=%u remains=%zu",
                    expected, stream.in_remain());
                throw Error(ERR_FSCC_DATA_TRUNCATED);
            }
        }

        this->DeviceType      = stream.in_uint32_le();
        this->Characteristics = stream.in_uint32_le();
    }

    inline static size_t size() {
        return 8;   // DeviceType(4) + Characteristics(4)
    }

private:
    inline static const char * get_DeviceType_name(uint32_t DeviceType) {
        switch (DeviceType) {
            case FILE_DEVICE_CD_ROM: return "FILE_DEVICE_CD_ROM";
            case FILE_DEVICE_DISK:   return "FILE_DEVICE_DISK";
        }

        return "<unknown>";
    }

    size_t str(char * buffer, size_t size) const {
        size_t length = ::snprintf(buffer, size,
            "FileFsDeviceInformation: DeviceType=%s(0x%X) Characteristics=0x%X",
            this->get_DeviceType_name(this->DeviceType), this->DeviceType,
            this->Characteristics);
        return ((length < size) ? length : size - 1);
    }

public:
    inline void log(int level) const {
        char buffer[2048];
        this->str(buffer, sizeof(buffer));
        buffer[sizeof(buffer) - 1] = 0;
        LOG(level, "%s", buffer);
    }

    void log() const {
        LOG(LOG_INFO, "     File Fs Device Information:");
        LOG(LOG_INFO, "          * DeviceType      = 0x%08x (4 bytes): %s", this->DeviceType, this->get_DeviceType_name(this->DeviceType));
        LOG(LOG_INFO, "          * Characteristics = 0x%08x (4 bytes)", this->Characteristics);
    }
};



// 2.4.42 FileNotifyInformation

// The FILE_NOTIFY_INFORMATION structure contains the changes that the client is being notified of. The structure consists of the following:

// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// | | | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| |
// |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|
// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// |                        NextEntryOffset                        |
// +---------------------------------------------------------------+
// |                             Action                            |
// +---------------------------------------------------------------+
// |                         FileNameLength                        |
// +---------------------------------------------------------------+
// |                       FileName (variable)                     |
// +---------------------------------------------------------------+
// |                              ...                              |
// +---------------------------------------------------------------+

// NextEntryOffset (4 bytes): The offset, in bytes, from the beginning of this structure to the subsequent FILE_NOTIFY_INFORMATION structure. If there are no subsequent structures, the NextEntryOffset field MUST be 0. NextEntryOffset MUST always be an integral multiple of 4. The FileName array MUST be padded to the next 4-byte boundary counted from the beginning of the structure.

// Action (4 bytes): The changes that occurred on the file. This field MUST contain one of the following values.

//  +------------------------------------+--------------------------------------------+
//  | Value                              | Meaning                                    |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_ADDED                  | The file was added to the directory.       |
//  | 0x00000001                         |                                            |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_REMOVED                | The file was removed from the              |
//  | 0x00000002                         | directory.                                 |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_MODIFIED               | The file was modified. This can be         |
//  | 0x00000003                         | a change to the data or attributes         |
//  |                                    | of the file.                               |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_RENAMED_OLD_NAME       | The file was renamed, and this is          |
//  | 0x00000004                         | the old name. If the new name              |
//  |                                    | resides within the directory being         |
//  |                                    | monitored, the client will also            |
//  |                                    | receive the                                |
//  |                                    | FILE_ACTION_RENAMED_NEW_NAME bit           |
//  |                                    | value as described in the next list        |
//  |                                    | item. If the new name resides              |
//  |                                    | outside of the directory being             |
//  |                                    | monitored, the client will not             |
//  |                                    | receive the                                |
//  |                                    | FILE_ACTION_RENAMED_NEW_NAME bit           |
//  |                                    | value.                                     |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_RENAMED_NEW_NAME       | The file was renamed, and this is the new  |
//  | 0x00000005                         | name. If the old name resides within the   |
//  |                                    | directory being monitored, the client will |
//  |                                    | also receive the                           |
//  |                                    | FILE_ACTION_RENAME_OLD_NAME bit value. If  |
//  |                                    | the old name resides outside of the        |
//  |                                    | directory being monitored, the client will |
//  |                                    | not receive the                            |
//  |                                    | FILE_ACTION_RENAME_OLD_NAME bit value.     |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_ADDED_STREAM           | The file was added to a named stream.      |
//  | 0x00000006                         |                                            |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_REMOVED_STREAM         | The file was removed from the named        |
//  | 0x00000007                         | stream.                                    |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_MODIFIED_STREAM        | The file was modified. This can be a       |
//  | 0x00000008                         | change to the data or attributes of the    |
//  |                                    | file.                                      |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_REMOVED_BY_DELETE      | An object ID was removed because the file  |
//  | 0x00000009                         | the object ID referred to was deleted.     |
//  |                                    |                                            |
//  |                                    | This notification is only sent when the    |
//  |                                    | directory being monitored is the special   |
//  |                                    | directory                                  |
//  |                                    | "\$Extend\$ObjId:$O:$INDEX_ALLOCATION".    |
//  |                                    | <125>                                      |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_ID_NOT_TUNNELLED       | An attempt to tunnel object ID information |
//  | 0x0000000A                         | to a file being created or renamed failed  |
//  |                                    | because the object ID is in use by another |
//  |                                    | file on the same volume.                   |
//  |                                    |                                            |
//  |                                    | This notification is only sent when the    |
//  |                                    | directory being monitored is the special   |
//  |                                    | directory                                  |
//  |                                    | "\$Extend\$ObjId:$O:$INDEX_ALLOCATION".    |
//  |                                    | <126>                                      |
//  +------------------------------------+--------------------------------------------+
//  | FILE_ACTION_TUNNELLED_ID_COLLISION | An attempt to tunnel object ID information |
//  | 0x0000000B                         | to a file being renamed failed because the |
//  |                                    | file already has an object ID.             |
//  |                                    |                                            |
//  |                                    | This notification is only sent when the    |
//  |                                    | directory being monitored is the special   |
//  |                                    | directory                                  |
//  |                                    | "\$Extend\$ObjId:$O:$INDEX_ALLOCATION".    |
//  |                                    | <127>                                      |
//  +------------------------------------+--------------------------------------------+

// If two or more files have been renamed, then the corresponding FILE_NOTIFY_INFORMATION entries for each file rename MUST be consecutive in this response, in order for the client to make the correct correspondence between old and new names.

// FileNameLength (4 bytes): The length, in bytes, of the file name in the FileName field.

// FileName (variable): A Unicode string with the name of the file that changed.

enum : uint32_t {

    FILE_ACTION_ADDED                  = 0x00000001,
    FILE_ACTION_REMOVED                = 0x00000002,
    FILE_ACTION_MODIFIED               = 0x00000003,
    FILE_ACTION_RENAMED_OLD_NAME       = 0x00000004,

    FILE_ACTION_RENAMED_NEW_NAME       = 0x00000005,
    FILE_ACTION_ADDED_STREAM           = 0x00000006,
    FILE_ACTION_REMOVED_STREAM         = 0x00000007,
    FILE_ACTION_MODIFIED_STREAM        = 0x00000008,
    FILE_ACTION_REMOVED_BY_DELETE      = 0x00000009,
    FILE_ACTION_ID_NOT_TUNNELLED       = 0x0000000A,
    FILE_ACTION_TUNNELLED_ID_COLLISION = 0x0000000B,
};

static inline
const char * get_Action_name(uint32_t action) {

    switch (action) {
        case FILE_ACTION_ADDED:                  return "FILE_ACTION_ADDED";
        case FILE_ACTION_REMOVED:                return "FILE_ACTION_REMOVED";
        case FILE_ACTION_MODIFIED:               return "FILE_ACTION_MODIFIED";
        case FILE_ACTION_RENAMED_OLD_NAME:       return "FILE_ACTION_RENAMED_OLD_NAME";
        case FILE_ACTION_RENAMED_NEW_NAME:       return "FILE_ACTION_RENAMED_NEW_NAME";
        case FILE_ACTION_ADDED_STREAM:           return "FILE_ACTION_ADDED_STREAM";
        case FILE_ACTION_REMOVED_STREAM:         return "FILE_ACTION_REMOVED_STREAM";
        case FILE_ACTION_MODIFIED_STREAM:        return "FILE_ACTION_MODIFIED_STREAM";
        case FILE_ACTION_REMOVED_BY_DELETE:      return "FILE_ACTION_REMOVED_BY_DELETE";
        case FILE_ACTION_ID_NOT_TUNNELLED:       return "FILE_ACTION_ID_NOT_TUNNELLED";
        case FILE_ACTION_TUNNELLED_ID_COLLISION: return "FILE_ACTION_TUNNELLED_ID_COLLISION";
    }

    return "<unknown>";
}

struct FileNotifyInformation {

    uint32_t NextEntryOffset = 0;
    uint32_t Action = 0;

    std::string FileName;


    FileNotifyInformation() = default;

    FileNotifyInformation(uint32_t NextEntryOffset, uint32_t Action, std::string FileName)
      : NextEntryOffset(NextEntryOffset)
      , Action(Action)
      , FileName(FileName)
      {}

    void emit(OutStream & stream) const {
        stream.out_uint32_le(this->NextEntryOffset);
        stream.out_uint32_le(this->Action);
        stream.out_uint32_le(this->FileName.size());
        stream.out_copy_bytes(reinterpret_cast<const uint8_t *>(this->FileName.data()), this->FileName.size());
    }

    void receive(InStream & stream) {
        this->NextEntryOffset = stream.in_uint32_le();
        this->Action = stream.in_uint32_le();
        size_t size = stream.in_uint32_le();
        uint8_t * data = nullptr;
        stream.in_copy_bytes(data, size);
        this->FileName = std::string(reinterpret_cast<const char *>(data), size);
    }

    void log() const {
        LOG(LOG_INFO, "     File Notify Information:");
        LOG(LOG_INFO, "          * NextEntryOffset = 0x%08x (4 bytes)", this->NextEntryOffset);
        LOG(LOG_INFO, "          * Action          = 0x%08x (4 bytes): %s", this->Action, get_Action_name(this->Action));
        LOG(LOG_INFO, "          * FileNameLength  = %zu (4 bytes)", this->FileName.size());
        LOG(LOG_INFO, "          * FileName        = \"%s\"", this->FileName);
    }
};





}   // namespace fscc

